#include "VcProject.h"


#include <wx/file.h>
#include <wx/tokenzr.h>
#include <wx/longlong.h>
#include <wx/textfile.h>
#include <wx/regex.h>
#include "wx/except.h"

#include "MemMgr.h"

#include "VcSln.h"

#include "main.h"



// now that we have MyDirectory declaration in scope we may finish the
// definition of ArrayOfDirectories -- note that this expands into some C++
// code and so should only be compiled once (i.e., don't put this in the
// header, but into a source file or you will get linking errors)
#include <wx/arrimpl.cpp> // this is a magic incantation which must be done!
WX_DEFINE_OBJARRAY(ArrayOfCustomUnityBuild);


CommandDescriptorArray VcProject::s_compileCommandList;
CommandDescriptorArray VcProject::s_linkCommandList;
CommandDescriptorArray VcProject::s_procDistccArray;
CommandDescriptorArray VcProject::s_procLocalArray;

bool VcProject::s_atLeastOneCompiledLibUsed = false;
wxArrayString VcProject::s_newlyCompiledLibs;


void NormalizePath(wxString& file);


VcProject::VcProject(void)
{
	m_targetChanged = false;
	m_includedInSolution = false;

	m_useAutoGeneratedUnityBuilds = false;
	m_autoGeneratedUBNumber = 0;


	/** wxString <OutDir> from VS project file*/
	m_targetOutDirFromVS = wxEmptyString;

	/** wxString <IntDir> from VS project file*/
	m_targetIntDirFromVS = wxEmptyString;

	/** wxString <TargetName> from VS project file*/
	m_targetNameFromVS = wxEmptyString;

	/** wxString <TargetExt> from VS project file*/
	m_targetOutTypeFromVS = wxEmptyString;

	m_targetOutType = wxEmptyString;


	m_currentCUBIndex = -1;
	m_currentCUBFilterIsRecursive = 0;
	m_currentCUBFilterRule = wxEmptyString;

	m_useAlreadyCompiledLib = false;

	SetName(wxEmptyString);
	SetFileName(wxEmptyString);
}


VcProject::VcProject(const wxString& name, const wxString& fileName)
{
	//wxPrintf(wxString(wxT("VcProject ")) + name + wxT(" ") + fileName + wxT("\n"));

	m_targetChanged = false;
	m_includedInSolution = false;

	m_useAutoGeneratedUnityBuilds = false;
	m_autoGeneratedUBNumber = 0;

	m_targetOutType = wxEmptyString;


	m_currentCUBIndex = -1;
	m_currentCUBFilterIsRecursive = 0;
	m_currentCUBFilterRule = wxEmptyString;

	m_useAlreadyCompiledLib = false;

	SetName(name);
	if (name == wxT("all"))
	{
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("Wrong project name! Please rename the project 'all' to avoid conflicts!\n"));
	}

	SetFileName(fileName);
}

void VcProject::Clear(void)
{
	if (sln2gccApp::GetAbortProgram())
		return;

	s_newlyCompiledLibs.Clear();

	CommandDescriptorArray::iterator it = s_procLocalArray.begin();
	while (it != s_procLocalArray.end())
	{
		CommandDescriptor* cd = *it;
		if (cd)
		{
			if (cd->IsJobEnd())
				delete cd;
			else
				continue;

		}

		it = s_procLocalArray.erase(it);
	}

	it = s_procDistccArray.begin();
	while (it != s_procDistccArray.end())
	{
		CommandDescriptor* cd = *it;
		if (cd)
		{
			if (cd->IsJobEnd())
				delete cd;
			else
				continue;
		}

		it = s_procDistccArray.erase(it);
	}
}

VcProject::~VcProject(void)
{
	static int a = 0;
	a++;
}

bool VcProject::HasTargetChanged()
{
	return m_targetChanged;
}

wxString VcProject::GetFileName()
{
	return m_fileName;
}
void VcProject::SetFileName(const wxString& fileName)
{
	m_fileName = fileName;
}

bool VcProject::IsIncludedInProject()
{
	return m_includedInSolution;
}
void VcProject::SetIncludedInSolution(bool includedInProject)
{
	m_includedInSolution = includedInProject;
}

wxString VcProject::GetName()
{
	return m_name;
}
void VcProject::SetName(const wxString& name)
{
	m_name = name;
}


void VcProject::SetProjectCS(const Declarations& projectDecl)
{
	m_projectDecl = projectDecl;
}

bool VcProject::Parse()
{
	wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' parsing... ") + wxT("\n"));

	if (!wxFile::Exists(m_fileName))
	{
		ERROR_PRINTF(wxString(wxT("file")), wxT("project file does not exist: ") + m_fileName + wxT("\n"));
		sln2gccApp::SetErrorCode(1);
		return false;
	}

	wxFileName projectFileName(m_fileName);

	this->m_projectDecl[wxT("ProjectDir")] = projectFileName.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR);

	if (projectFileName.GetExt() == wxT("vcxproj"))
	{
		return ParseVCXPROJ();
	}
	else if (projectFileName.GetExt() == wxT("vcproj"))
	{
		return ParseVCPROJ();
	}

	return false;
}

bool VcProject::ParseVCPROJ()
{
	bool useAdditionalIncludeDirectories = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_ADDITIONAL_INCLUDE_DIRECTORIES_FROM_VS"), m_projectDecl);
	//if(useAdditionalIncludeDirectories)
	//    wxPrintf(wxString(wxT("1 useAdditionalIncludeDirectories: true \n\n")));
	//else
	//    wxPrintf(wxString(wxT("1 useAdditionalIncludeDirectories: false \n\n")));

	bool usePropertyGroup = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_PROPERTY_GROUP_FROM_VS"), m_projectDecl);

	wxXmlDocument  vcproj;

	if (!vcproj.Load(m_fileName))
	{
		ERROR_PRINTF(wxString(wxT("file")), wxT("VisualStudio 2008 (vcproj) Project file cannot be opened: ") + m_fileName + wxT("\n"));
		sln2gccApp::SetErrorCode(1);
		return false;
	}


	wxXmlNode* root = vcproj.GetRoot();

	if ((root) && (root->GetName() == wxT("VisualStudioProject")))
	{
		wxXmlNode* ConfigurationsNode = root->GetChildren(wxT("Configurations"));
		if (ConfigurationsNode)
		{
			wxString configChoosed = wxEmptyString;

			if (sln2gccApp::s_typeOfBuild == STR_RELEASE)
			{
				configChoosed = this->m_projectDecl[wxT("CONFIG_RELEASE")];
				if (configChoosed == wxEmptyString)
				{
					WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxString(wxT("not defined CONFIG_RELEASE\n")));
				}
			}
			else if (sln2gccApp::s_typeOfBuild == STR_DEBUG)
			{
				configChoosed = this->m_projectDecl[wxT("CONFIG_DEBUG")];
				if (configChoosed == wxEmptyString)
				{
					WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxString(wxT("not defined CONFIG_DEBUG\n")));
				}
			}
			else
			{
				WARNING_PRINTF(wxString(wxT("command parameters")), wxString(wxT("typeOfBuild=")) + sln2gccApp::s_typeOfBuild + wxT(" differ from 'release' or 'debug'\n"));
			}

			wxString configAvailable = wxEmptyString;
			wxXmlNode* configNodeMatch = NULL;
			wxString configNodeMatchName = wxEmptyString;
			wxXmlNode* configNode = ConfigurationsNode->GetChildren();
			while (configNode)
			{
				if (configNode->GetName() == wxT("Configuration"))
				{
					wxString name = configNode->GetPropVal(wxT("Name"), wxEmptyString);
					if (name.Find(configChoosed) == 0)
					{
						configNodeMatch = configNode;
					}
					else if ((configChoosed == wxEmptyString) && (configNodeMatch == NULL))
					{
						configNodeMatch = configNode;
					}
					configAvailable += wxString(wxT("\t")) + name + wxT("\n");
				}

				configNode = configNode->GetNext();
			};

			if (configNodeMatch)
			{
				configNodeMatchName = configNodeMatch->GetPropVal(wxT("Name"), wxEmptyString);
				//configNodeMatchName = configNodeMatchName.Mid(0, configNodeMatchName.IndexOf('|'));
			}

			if (configChoosed == wxEmptyString)
			{
				WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxString(wxT("Configuration available:\n")) + configAvailable);
				WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxString(wxT("Automatic config choosed: ")) + configNodeMatchName + wxT(" \n"));
			}

			if (configNodeMatch)
			{
				wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' configuration ") + configNodeMatchName + wxT("\n"));
				m_MSVCConfigurationUsed = configNodeMatchName;

				wxXmlNode* toolNode = configNodeMatch->GetChildren();
				while (toolNode)
				{
					if (toolNode->GetName() == wxT("Tool"))
					{
						wxString nameOfTool = toolNode->GetPropVal(wxT("Name"), wxEmptyString);
						if (nameOfTool == wxT("VCCLCompilerTool"))
						{
							if (useAdditionalIncludeDirectories)
							{
								wxString AdditionalIncludeDirectories = toolNode->GetPropVal(wxT("AdditionalIncludeDirectories"), wxEmptyString);
								//wxPrintf(wxString(wxT("AdditionalIncludeDirectories: ")) + AdditionalIncludeDirectories + wxT(" \n\n"));

								///check if the path contains spaces
								wxStringTokenizer tkn(AdditionalIncludeDirectories, wxT(";"));
								while (tkn.HasMoreTokens())
								{
									wxString newTok = tkn.GetNextToken();
									newTok.Trim().Trim(false);
									if (newTok == wxEmptyString) continue;

									if (newTok.IndexOf(' ') != wxNOT_FOUND)
									{
										WARNING_PRINTF(wxString(wxT("file")), wxString(wxT("space (' ') detected in path AdditionalIncludeDirectories: ")) + newTok + wxT(" for project '") + this->GetName() + wxT("' \n"));
									}
								}
								///check if the path contains spaces


								this->m_projectDecl[wxT("INCLUDE_PATHS")] += wxString(wxT(" ")) + AdditionalIncludeDirectories;
							}
						}
						else if (nameOfTool == wxT("VCLinkerTool"))
						{


						}
					}

					toolNode = toolNode->GetNext();
				};

				wxString tempStr = this->m_projectDecl[wxT("INCLUDE_PATHS")];
				REPLACE_SEPARATORS_WITH_SPACE(tempStr);
				this->m_projectDecl[wxT("INCLUDE_PATHS")] = tempStr;

				//wxPrintf(wxString(wxT("this->m_projectSettings.INCLUDE_PATHS: ")) + this->m_projectSettings.INCLUDE_PATHS + wxT(" \n\n"));
			}
			else
			{
				ERROR_PRINTF(wxString(wxT("file")), wxString(wxT("cannot find: ")) + configChoosed + wxT(" in ") + this->GetFileName() + wxT(" \n"));
				ERROR_PRINTF(wxString(wxT("file")), wxString(wxT("\tTip: configuration available:\n")) + configAvailable + wxT(" \n"));
				sln2gccApp::SetErrorCode(1);
				return false;
			}

		}
		else
		{
			ERROR_PRINTF(wxString(wxT("file")), wxString(wxT("cannot find Configurations xml node in ")) + this->GetFileName() + wxT(" \n"));
			return false;
		}


		wxXmlNode* filesNode = root->GetChildren(wxT("Files"));
		if (filesNode)
		{
			CollectVcprojFiles(filesNode);
		}
		else
		{
			WARNING_PRINTF(wxString(wxT("file")), wxString(wxT("cannot find Files")) + wxT(" in ") + this->GetFileName() + wxT(" \n"));
		}
	}
	else
	{
		ERROR_PRINTF(wxString(wxT("file")), wxT("vcproj file wrong format: ") + m_fileName + wxT("\n"));
		sln2gccApp::SetErrorCode(1);
		return false;
	}

	return true;
}

bool VcProject::ParseVCXPROJ()
{

	bool useAdditionalIncludeDirectories = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_ADDITIONAL_INCLUDE_DIRECTORIES_FROM_VS"), m_projectDecl);
	//if (useAdditionalIncludeDirectories)
	//    wxPrintf(wxString(wxT("2 useAdditionalIncludeDirectories: true \n\n")));
	//else
	//    wxPrintf(wxString(wxT("2 useAdditionalIncludeDirectories: false \n\n")));

	bool usePropertyGroup = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_PROPERTY_GROUP_FROM_VS"), m_projectDecl);

	wxXmlDocument  vcxproj;

	if (!vcxproj.Load(m_fileName))
	{
		ERROR_PRINTF(wxString(wxT("file")), wxT("VisualStudio 2010 (vcxproj) Project file cannot be opened: ") + m_fileName + wxT("\n"));
		sln2gccApp::SetErrorCode(1);
		return false;
	}


	wxXmlNode* root = vcxproj.GetRoot();

	if ((root) && (root->GetName() == wxT("Project")))
	{
		wxXmlNode* ItemGroup = root->GetChildren(wxT("ItemGroup"));
		wxString ItemGroup_Label = wxEmptyString;
		if (ItemGroup)
		{
			ItemGroup_Label = ItemGroup->GetPropVal(wxT("Label"), wxEmptyString);
		}
		if (ItemGroup_Label == wxT("ProjectConfigurations"))
		{
			wxString configChoosed = wxEmptyString;

			if (sln2gccApp::s_typeOfBuild == STR_RELEASE)
			{
				configChoosed = this->m_projectDecl[wxT("CONFIG_RELEASE")];
				if (configChoosed == wxEmptyString)
				{
					configChoosed = wxT("Release");

					WARNING_PRINTF(wxString(wxT("")), wxString(wxT("not defined CONFIG_RELEASE! Will be used the default value '")) + configChoosed + wxT("'.\n"));
				}
			}
			else if (sln2gccApp::s_typeOfBuild == STR_DEBUG)
			{
				configChoosed = this->m_projectDecl[wxT("CONFIG_DEBUG")];
				if (configChoosed == wxEmptyString)
				{
					configChoosed = wxT("Debug");
					WARNING_PRINTF(wxString(wxT("")), wxString(wxT("not defined CONFIG_DEBUG! Will be used the default value '")) + configChoosed + wxT("'.\n"));
				}
			}
			else
			{
				WARNING_PRINTF(wxString(wxT("command parameters")), wxString(wxT("typeOfBuild=")) + sln2gccApp::s_typeOfBuild + wxT(" differ from 'release' or 'debug'\n"));
			}



			wxString configAvailable = wxEmptyString;
			wxXmlNode* ProjectConfiguration = ItemGroup->GetChildren();
			while (ProjectConfiguration)
			{
				if (ProjectConfiguration->GetName() == wxT("ProjectConfiguration"))
				{
					wxString ProjectConfiguration_Include = ProjectConfiguration->GetPropVal(wxT("Include"), wxEmptyString);
					if (ProjectConfiguration_Include != wxEmptyString)
					{

						if (ProjectConfiguration_Include.Find(configChoosed) == 0)
						{
							m_MSVCConfigurationUsed = configChoosed;
							break;
						}

						configAvailable += wxString(wxT("\t")) + ProjectConfiguration_Include + wxT("\n");
						//wxPrintf(wxString(wxT("ProjectConfiguration_Include=")) + ProjectConfiguration_Include  + wxT(" ") + wxT("\n"));
					}

				}

				ProjectConfiguration = ProjectConfiguration->GetNext();
			}

			if (m_MSVCConfigurationUsed == wxEmptyString)
			{
				ERROR_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxString(wxT("Configuration '")) + configChoosed + wxT("' not found! Available configuration:\n") + configAvailable);
				sln2gccApp::SetErrorCode(1);
				return false;
			}
		}
		else
		{
			ERROR_PRINTF(wxString(wxT("file")), wxT("vcxproj file wrong format: Does not have <ItemGroup Label=\"ProjectConfigurations\"> \n"));
			sln2gccApp::SetErrorCode(1);
			return false;
		}

		if (useAdditionalIncludeDirectories)
		{
			wxXmlNode* ItemDefinitionGroup = root->GetChildren(wxT("ItemDefinitionGroup"));
			while (ItemDefinitionGroup)
			{
				if (ItemDefinitionGroup->GetName() == wxT("ItemDefinitionGroup"))
				{
					wxString ItemDefinitionGroup_Condition = ItemDefinitionGroup->GetPropVal(wxT("Condition"), wxEmptyString);
					if (ItemDefinitionGroup_Condition != wxEmptyString)
					{
						wxString config = ItemDefinitionGroup_Condition.SubString(ItemDefinitionGroup_Condition.LastIndexOf('=') + 1, ItemDefinitionGroup_Condition.size());
						config.Replace(wxT("'"), wxT(" "));
						config.Trim().Trim(false);
						//wxPrintf(wxString(wxT("config========================")) + config  + wxT(" ") + wxT("\n"));
						//wxPrintf(wxString(wxT("m_MSVCConfigurationUsed========================")) + m_MSVCConfigurationUsed + wxT(" ") + wxT("\n"));
						if (config == m_MSVCConfigurationUsed)
						{
							wxXmlNode* ClCompile = ItemDefinitionGroup->GetChildren(wxT("ClCompile"));
							if (ClCompile)
							{
								wxXmlNode* AdditionalIncludeDirectories = ClCompile->GetChildren(wxT("AdditionalIncludeDirectories"));
								if (AdditionalIncludeDirectories)
								{
									wxString content = AdditionalIncludeDirectories->GetNodeContent();
									//wxPrintf(wxString(wxT("AdditionalIncludeDirectories=")) + content  + wxT(" ") + wxT("\n"));

									wxStringTokenizer tkn(content, wxT(";"));
									while (tkn.HasMoreTokens())
									{
										wxString newTok = tkn.GetNextToken();
										newTok.Trim().Trim(false);
										if (newTok == wxEmptyString) continue;

										if (newTok.IndexOf(' ') != wxNOT_FOUND)
										{
											WARNING_PRINTF(wxString(wxT("file")), wxString(wxT("space (' ') detected in path AdditionalIncludeDirectories: ")) + newTok + wxT(" for project '") + this->GetName() + wxT("' \n"));
										}
									}
									///check if the path contains spaces

									REPLACE_SEPARATORS_WITH_SPACE(content);

									this->m_projectDecl[wxT("INCLUDE_PATHS")] += wxString(wxT(" ")) + content;

								}
							}

						}

					}

				}

				ItemDefinitionGroup = ItemDefinitionGroup->GetNext();
			}
		}

		if (usePropertyGroup) //use output and temp folder from VS
		{
			wxXmlNode* PropertyGroup = root->GetChildren(wxT("PropertyGroup"));
			while (PropertyGroup)
			{
				if (PropertyGroup->GetName() == wxT("PropertyGroup"))
				{
					wxString PropertyGroup_Condition = PropertyGroup->GetPropVal(wxT("Condition"), wxEmptyString);
					if (PropertyGroup_Condition != wxEmptyString)
					{
						wxString config = PropertyGroup_Condition.SubString(PropertyGroup_Condition.LastIndexOf('=') + 1, PropertyGroup_Condition.size());
						config.Replace(wxT("'"), wxT(" "));
						config.Trim().Trim(false);

						if (config == m_MSVCConfigurationUsed)
						{
							wxXmlNode* OutDir = PropertyGroup->GetChildren(wxT("OutDir"));
							if (OutDir)
							{
								m_targetOutDirFromVS = OutDir->GetNodeContent();
								//PRINTF(COLOR_YELLOW, wxT("\nOutDir=%s"), m_targetOutDirFromVS);
							}

							wxXmlNode* IntDir = PropertyGroup->GetChildren(wxT("IntDir"));
							if (IntDir)
							{
								m_targetIntDirFromVS = IntDir->GetNodeContent();
								//PRINTF(COLOR_YELLOW, wxT("\nIntDir=%s"), m_targetIntDirFromVS);
							}

							wxXmlNode* TargetName = PropertyGroup->GetChildren(wxT("TargetName"));
							if (TargetName)
							{
								m_targetNameFromVS = TargetName->GetNodeContent();
								//PRINTF(COLOR_YELLOW, wxT("\nTargetName=%s"), m_targetNameFromVS);
							}

							wxXmlNode* TargetExt = PropertyGroup->GetChildren(wxT("TargetExt"));
							if (TargetExt)
							{
								m_targetOutTypeFromVS = TargetExt->GetNodeContent();
								//PRINTF(COLOR_YELLOW, wxT("\nTargetExt=%s"), m_targetOutTypeFromVS);
							}
						}
					}
				}

				PropertyGroup = PropertyGroup->GetNext();
			}
		}
	}
	else
	{
		ERROR_PRINTF(wxString(wxT("file")), wxT("vcxproj file wrong format: ") + m_fileName + wxT("\n"));
		sln2gccApp::SetErrorCode(1);
		return false;
	}

	CollectVcxprojFiles(root);

	return true;
}



bool VcProject::IsSourceFile(wxString extension)
{
	int arrSize = m_typesOfFilesToBeCompiled.size();
	for (int i = 0; i < arrSize; i++)
	{
		if (m_typesOfFilesToBeCompiled[i] == extension)
		{
			return true;
		}
	}

	return false;
}


bool VcProject::IsHeaderFile(wxString extension)
{
	return (extension == wxT("h"));
}


/**
 * This function will search in the VisualStudio project (*.vcproj) for all the available files.
 * Is a Recursive function. For each Filter , this function will call himself.
 * The ignored Filters and Files will not be added to the list.
 */
void VcProject::CollectVcprojFiles(wxXmlNode* node)
{
	bool useExcludeFromBuildVSFlag = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_EXCLUDEFROMBUILD_VS_FLAG"), m_projectDecl);

	bool generatePCHForAll = false;//CHECK_MACRO_IF_IS_ENABLED(wxT("USE_GENERATE_PCH_FOR_ALL_HEADERS"), m_projectDecl);

	/**
	 * first 'while loop' will search for files. Each file will be added to the default file list 'm_sourceFiles'
	 * or to the current Custom Unity Build (s_currentCUBIndex) if the file match the rule (s_currentCUBFilterRule).
	 */
	wxXmlNode* child = node->GetChildren();
	while (child)
	{
		if (child->GetName() == wxT("File"))
		{
			wxString file = child->GetPropVal(wxT("RelativePath"), wxEmptyString);
			if (file != wxEmptyString)
			{

				bool isIgnored = IsIgnored(file);

				if (!isIgnored && useExcludeFromBuildVSFlag)
				{
					wxXmlNode* fileConfigurationNode = child->GetChildren(wxT("FileConfiguration"));

					/* Iterate over file configuration nodes, and if we encountered own config... add it to ignore list */
					while (fileConfigurationNode) {
						wxString			config = fileConfigurationNode->GetPropVal(wxT("Name"), wxEmptyString);
						wxString excludedFromBuild = fileConfigurationNode->GetPropVal(wxT("ExcludedFromBuild"), wxEmptyString);

						if ((excludedFromBuild.Upper() == wxT("TRUE") || excludedFromBuild == wxT("1") || excludedFromBuild.Upper() == wxT("YES")) // Marked as excluded
							&& config == m_MSVCConfigurationUsed)													 // Exclusion config equals current building config
						{
							isIgnored = true;
						}

						fileConfigurationNode = fileConfigurationNode->GetNext();
					}
				}

				if (!isIgnored)
				{
					wxString ext = wxFileName(file).GetExt();

					if (IsSourceFile(ext))
					{
						//wxPrintf(file + wxT(" with extension: ") + ext + wxT(" IsSourceFile \n"));

						bool addedToCUB = false;
						if (m_currentCUBIndex != -1)
						{
							CustomUnityBuild* cub = m_customUBFiles[m_currentCUBIndex];

							if (FileNameMatch(file, m_currentCUBFilterRule))
							{
								cub->m_files.Add(file);
								addedToCUB = true;
							}
						}

						if (!addedToCUB)
						{
							//added to the default source list
							this->m_sourceFiles.Add(file);
						}

						//wxPrintf(file + wxT("\n"));

					}
					else if (IsHeaderFile(ext))
					{
						if (generatePCHForAll)
						{
							//wxPrintf(file + wxT(" with extension: ") + ext + wxT(" IsHeaderFile \n"));
							this->m_headerFiles.Add(file);
						}
						else if (this->m_projectDecl[wxT("USE_PCH_FILE")] != wxEmptyString)
						{
							if (wxFileName(this->m_projectDecl[wxT("USE_PCH_FILE")]).GetFullName() == wxFileName(file).GetFullName())
							{
								this->m_headerFiles.Add(file);
								wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' use '") + wxFileName(file).GetFullName() + wxT("' for PCH!\n"));
							}
						}
					}
				}
				else
				{
					sln2gccApp::ChangeColour(COLOR_GRAY);
					wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' ignoring file '") + wxFileName(file).GetFullName() + wxT("'\n"));
					sln2gccApp::ChangeColour(COLOR_WHITE);
				}
			}
		}

		child = child->GetNext();
	};


	/**
	 * reset the current Custom UnityBuild (s_currentCUBIndex) if
	 * is not recursive.
	 */
	if (m_currentCUBFilterIsRecursive == 0)
	{
		m_currentCUBIndex = -1;
		m_currentCUBFilterRule = wxEmptyString;
	}



	/**
	 * The second 'while loop' will search for VisualStudio 'Filter' (aka folders in VS).
	 * For each Filter will check if is ignored or not.
	 */
	child = node->GetChildren();
	while (child)
	{
		wxString filterName = wxEmptyString;

		if (child->GetName() == wxT("Filter"))
		{
			filterName = child->GetPropVal(wxT("Name"), wxEmptyString);

			bool filterIsIgnored = false;
			for (unsigned int i = 0; i < m_filtersIgnored.size(); i++)
			{
				if (m_filtersIgnored[i] == filterName)
				{
					sln2gccApp::ChangeColour(COLOR_GRAY);
					wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' ignoring VS Filter '") + filterName + wxT("'\n"));
					sln2gccApp::ChangeColour(COLOR_WHITE);

					filterIsIgnored = true;
					break;
				}
			}

			if (filterIsIgnored)
			{
				child = child->GetNext();
				continue;
			}


			bool currentCUBwasChanged = false;
			if ((m_currentCUBIndex == -1) || (m_currentCUBFilterIsRecursive == 0))
			{
				int cubSize = m_customUBFiles.size();
				for (int i = 0; i < cubSize; i++)
				{
					CustomUnityBuild* cub = m_customUBFiles[i];

					if (cub->m_recursive.find(filterName) != cub->m_recursive.end())
					{
						m_currentCUBIndex = i;
						m_currentCUBFilterIsRecursive = cub->m_recursive[filterName];
						m_currentCUBFilterRule = cub->m_rule[filterName];
						currentCUBwasChanged = true;
						break;
					}
				}
			}


			//this is a recursive function
			CollectVcprojFiles(child);


			if (currentCUBwasChanged)
			{
				m_currentCUBIndex = -1;
				m_currentCUBFilterIsRecursive = 0;
				m_currentCUBFilterRule = wxEmptyString;
			}

		}

		child = child->GetNext();
	};
}




/**
 * This function will search in the VisualStudio 2010 project (*.vcxproj) for all the available files.
 * Is a Recursive function. For each Filter , this function will call himself.
 * The ignored Filters and Files will not be added to the list.
 */
void VcProject::CollectVcxprojFiles(wxXmlNode* node)
{
	bool useExcludeFromBuildVSFlag = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_EXCLUDEFROMBUILD_VS_FLAG"), m_projectDecl);

	bool generatePCHForAll = false;//CHECK_MACRO_IF_IS_ENABLED(wxT("USE_GENERATE_PCH_FOR_ALL_HEADERS"), m_projectDecl);


	wxXmlNode* ItemGroup = node->GetChildren();
	while (ItemGroup)
	{
		if (ItemGroup->GetName() == wxT("ItemGroup"))
		{
			wxXmlNode* ClCompile = ItemGroup->GetChildren();
			while (ClCompile)
			{
				if ((ClCompile->GetName() == wxT("ClCompile"))
					|| (ClCompile->GetName() == wxT("ClInclude")))
				{
					wxString file = ClCompile->GetPropVal(wxT("Include"), wxEmptyString);
					if (file != wxEmptyString)
					{
						bool isIgnored = IsIgnored(file);

						if (!isIgnored && useExcludeFromBuildVSFlag)
						{
							wxXmlNode* ExcludedFromBuild = ClCompile->GetChildren(wxT("ExcludedFromBuild"));
							while (ExcludedFromBuild)
							{
								wxString ExcludedFromBuild_Condition = ExcludedFromBuild->GetPropVal(wxT("Condition"), wxEmptyString);
								if (ExcludedFromBuild_Condition != wxEmptyString)
								{
									wxString config = ExcludedFromBuild_Condition.SubString(ExcludedFromBuild_Condition.LastIndexOf('=') + 1, ExcludedFromBuild_Condition.size());
									config.Replace(wxT("'"), wxT(" "));
									config.Trim().Trim(false);

									isIgnored = ((config == m_MSVCConfigurationUsed) && (IS_TRUE(ExcludedFromBuild->GetNodeContent())));
									if (isIgnored)
									{
										//add this file to the ignored list . This will be used for the future checks.
										this->m_filesIgnored.push_back(wxFileName(file).GetFullName());
										break;
									}
								}

								ExcludedFromBuild = ExcludedFromBuild->GetNext();
							}
						}

						if (!isIgnored)
						{
							wxString ext = wxFileName(file).GetExt();

							if (IsSourceFile(ext))
							{
								//added to the default source list
								this->m_sourceFiles.Add(file);
							}
							else if (IsHeaderFile(ext))
							{
								if (generatePCHForAll)
								{
									//wxPrintf(file + wxT(" with extension: ") + ext + wxT(" IsHeaderFile \n"));
									this->m_headerFiles.Add(file);
								}
								else if (this->m_projectDecl[wxT("USE_PCH_FILE")] != wxEmptyString)
								{
									if (wxFileName(this->m_projectDecl[wxT("USE_PCH_FILE")]).GetFullName() == wxFileName(file).GetFullName())
									{
										this->m_headerFiles.Add(file);
										wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' use '") + wxFileName(file).GetFullName() + wxT("' for PCH!\n"));
									}
								}
							}
						}
						else
						{
							sln2gccApp::ChangeColour(COLOR_GRAY);
							wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' ignoring file '") + wxFileName(file).GetFullName() + wxT("'\n"));
							sln2gccApp::ChangeColour(COLOR_WHITE);
						}
					}

				}

				ClCompile = ClCompile->GetNext();
			}


		}

		ItemGroup = ItemGroup->GetNext();
	}



	//search for filters:
	wxXmlDocument  vcxprojFilters;

	wxString fileNameFilters = wxFileName(m_fileName).GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR) + wxFileName(m_fileName).GetName() + wxT(".vcxproj.filters");

	if (!wxFileName::FileExists(fileNameFilters))
		return;

	if (!vcxprojFilters.Load(fileNameFilters))
	{
		WARNING_PRINTF(wxString(wxT("file")), wxT("VisualStudio 2010 (.vcxproj.filters) Project Filters file cannot be opened: ") + fileNameFilters + wxT("\n"));
		return;
	}


	wxXmlNode* root = vcxprojFilters.GetRoot();

	if ((root) && (root->GetName() == wxT("Project")))
	{
		wxXmlNode* ItemGroup = root->GetChildren();
		while (ItemGroup)
		{
			if (ItemGroup->GetName() == wxT("ItemGroup"))
			{
				wxXmlNode* ClCompile = ItemGroup->GetChildren();
				while (ClCompile)
				{
					if ((ClCompile->GetName() == wxT("ClCompile"))
						|| (ClCompile->GetName() == wxT("ClInclude")))
					{
						wxXmlNode* Filter = ClCompile->GetChildren(wxT("Filter"));
						wxString filterName = wxEmptyString;
						if (Filter) filterName = Filter->GetNodeContent();

						wxString file = ClCompile->GetPropVal(wxT("Include"), wxEmptyString);
						if (file != wxEmptyString)
						{
							bool isIgnored = IsIgnored(file);

							if (!isIgnored)
							{
								bool filterIsIgnored = false;
								for (unsigned int i = 0; i < m_filtersIgnored.size(); i++)
								{
									if (m_filtersIgnored[i] == filterName)
									{
										//sln2gccApp::ChangeColour(COLOR_GRAY);
										//wxPrintf(wxString(wxT("Project '")) + this->GetName()  + wxT("' ignoring VS Filter '") + filterName + wxT("'\n"));
										//sln2gccApp::ChangeColour(COLOR_WHITE);

										for (unsigned int j = 0; j < m_sourceFiles.size(); j++)
										{
											if (file == m_sourceFiles[j])
											{
												m_sourceFiles.RemoveAt(j);
												isIgnored = true;
												break;
											}
										}

										filterIsIgnored = true;
										break;
									}
								}

								if (filterIsIgnored)
								{
									ClCompile = ClCompile->GetNext();
									continue;
								}
							}


							bool currentCUBwasChanged = false;
							if ((m_currentCUBIndex == -1) || (m_currentCUBFilterIsRecursive == 0))
							{
								int cubSize = m_customUBFiles.size();
								for (int i = 0; i < cubSize; i++)
								{
									CustomUnityBuild* cub = m_customUBFiles[i];

									if (cub->m_recursive.find(filterName) != cub->m_recursive.end())
									{
										m_currentCUBIndex = i;
										m_currentCUBFilterIsRecursive = cub->m_recursive[filterName];
										m_currentCUBFilterRule = cub->m_rule[filterName];
										currentCUBwasChanged = true;
										break;
									}
								}
							}


							if (currentCUBwasChanged)
							{
								m_currentCUBIndex = -1;
								m_currentCUBFilterIsRecursive = 0;
								m_currentCUBFilterRule = wxEmptyString;
							}

						}

					}

					ClCompile = ClCompile->GetNext();
				}


			}

			ItemGroup = ItemGroup->GetNext();
		}
	}



}

wxString VcProject::GetWrokingPath()
{
	return sln2gccApp::s_outputPath + SEP + sln2gccApp::s_typeOfBuild + SEP + sln2gccApp::s_gccConfig + SEP + this->GetName() + SEP;
}

void VcProject::CloseAndRenameCurrentAUB(wxFile*& unityFile, wxString unityFileName, wxString unityFileNameTemp, bool alreadyExists)
{
	if (unityFile)
	{
		unityFile->Flush();
		unityFile->Close();
		delete unityFile;
		unityFile = NULL;

		//wxPrintf(wxT("Close1 unityFileNameUsed=") + unityFileNameUsed + wxT("\n"));

		if (alreadyExists)
		{
			if (!CompareFiles(unityFileName, unityFileNameTemp))
			{
				//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' DIFFERS\n"));
				::wxRenameFile(unityFileNameTemp, unityFileName, true);
			}
			else
			{
				//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' The same!\n"));
			}
		}

	}
}

bool VcProject::PrepareCompileCommands(Declarations decl, VcSln *sln, bool forceRelink, bool forceRecompile, bool isMainProject)
{
	m_useAlreadyCompiledLib = CHECK_MACRO_IF_IS_ENABLED(wxT("USE_ALREADY_COMPILED_LIB"), this->m_projectDecl);


	wxString OutBaseName = this->m_projectDecl[wxT("USE_SPECIFIC_OUTPUT_NAME")];
	if (OutBaseName == wxEmptyString)
	{
		OutBaseName = this->GetName();
	}
	else
	{
		OutBaseName.Replace(wxT(" "), wxT("_"));//get rid of all spaces
		PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("Project '")) + this->GetName() + wxT("' has specific output name '") + OutBaseName + wxT("' (flag USE_SPECIFIC_OUTPUT_NAME used)\n"));
	}


	if (m_targetOutType == wxT("exe"))
	{
		decl[wxT("OUT")] = OutBaseName + wxT(".") + m_targetOutType;
	}
	else if (m_targetOutType == wxT("dll"))
	{
		decl[wxT("OUT")] = OutBaseName + wxT(".") + m_targetOutType;
	}
	else if (m_targetOutType == wxT("so"))
	{
		decl[wxT("OUT")] = wxString(wxT("lib")) + OutBaseName + wxT(".") + m_targetOutType;
	}
	else if (m_targetOutType == wxT("lib"))
	{
		decl[wxT("OUT")] = OutBaseName + wxT(".") + m_targetOutType;
	}
	else if (m_targetOutType == wxT("a"))
	{
		decl[wxT("OUT")] = wxString(wxT("lib")) + OutBaseName + wxT(".") + m_targetOutType;
	}
	else
	{
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("Wrong Output type '") + m_targetOutType + wxT("' in project '") + this->GetName() + wxT("' !\n"));
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("Available values are: exe, dll, so, lib, a . ") + wxT("Assuming 'a' as a default value!\n"));
		m_targetOutType = wxT("a");
		decl[wxT("OUT")] = wxString(wxT("lib")) + OutBaseName + wxT(".") + m_targetOutType;
	}

	PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("Project '")) + this->GetName() + wxT("' output will be '") + decl[wxT("OUT")] + wxT("' \n"));




	// print a warning message if you use already compiled lib for the main project
	if (isMainProject && m_useAlreadyCompiledLib)
	{
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("USE_ALREADY_COMPILED_LIB flag for %s is ignored!\n"), this->GetName());
	}

	// delete the already compiled lib if user doesn't want to use it
	// this means that the lib will be/has been modified and the project needs to use the new one
	// that will be copied automatically after the linking step
	else if (!isMainProject && !m_useAlreadyCompiledLib)
	{
		wxString libPath = sln2gccApp::s_precompiledPath + SEP + sln2gccApp::s_typeOfBuild + SEP + sln2gccApp::s_gccConfig + SEP + decl[wxT("OUT")];

		wxFileName libFile(libPath);

		if (libFile.FileExists())
		{
			if (wxRemoveFile(libPath))
			{
				PRINTF(COLOR_GRAY, wxT("Deleted %s!\n"), libPath);
			}
			else
			{
				ERROR_PRINTF(libPath, wxT("Deleting file failed! Please manually delete this file!\n"));
			}
		}
	}
	// look for already compiled lib
	else if (!isMainProject && m_useAlreadyCompiledLib)
	{
		PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Using already compiled lib... (flag USE_ALREADY_COMPILED_LIB used)\n"));

		wxString libName = decl[wxT("OUT")];

		wxString libDir = sln2gccApp::s_precompiledPath + SEP + sln2gccApp::s_typeOfBuild + SEP + sln2gccApp::s_gccConfig + SEP;

		wxString libPath = libDir + libName;

		wxFileName libsDir(libDir);
		wxFileName libFile(libPath);

		if (libsDir.DirExists())
		{
			if (libFile.FileExists())
			{
				// library found
				// nothing more to be done for this project
				PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Already compiled lib %s found.\n"), libName);
				PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Skipping project '%s'.\n"), this->GetName());
				PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' It will be used as is.\n"));

				s_atLeastOneCompiledLibUsed = true;

				return true;
			}
			else
			{
				PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Already compiled library '%s' doesn't exist.\n"), libPath);
				PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' It will be created after the linking phase and will be used on future builds.\n"));
				//PRINTF(COLOR_GREEN,  wxT("Compiling process will continue...\n"));
			}
		}
		else
		{
			PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Directory %s doesn't exist. Creating it now...\n"), libDir);
			PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' Already compiled library '%s' doesn't exist.\n"), libPath);
			PRINTF(COLOR_YELLOW_DARK, wxString(wxT("Project '")) + this->GetName() + wxT("' It will be created after the linking phase and will be used on future builds.\n"));
			//PRINTF(COLOR_GREEN,  wxString(wxT("Project '")) + this->GetName()  + wxT("' Compiling process will continue\n"), libDir);

			if (libsDir.Mkdir(777, wxPATH_MKDIR_FULL) == false)
			{
				WARNING_PRINTF(libDir, wxT("FAILED creating directory!\n"));
			}
		}

		// only projects that have not found their already compiled lib will get here
		// we need to keep track of those projects in order to copy their newly created libs

		// source
		s_newlyCompiledLibs.Add(sln2gccApp::s_outputPath + SEP + sln2gccApp::s_typeOfBuild + SEP + sln2gccApp::s_gccConfig + SEP + this->GetName() + SEP + libName);

		// destination
		s_newlyCompiledLibs.Add(libPath);
	}

	int fileChanged = 0;

	if (m_sourceFiles.size() <= 0)
	{
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("There is not file to compile in project '") + this->GetName() + wxT("'\n"));
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("reason1: no source file in VisualStudio solution (*.sln)!\n"));
		WARNING_PRINTF(!IS_FALSE(m_s2gFile) ? m_s2gFile : sln2gccApp::s_inputFile, wxT("reason2: all the files are ignored from sln2gcc.xml config!\n"));

		return false;
	}



	bool generateBreakpadSym = CHECK_MACRO_IF_IS_ENABLED(wxT("GENERATE_BREAKPAD_SYM"), decl);
	bool generateDsym = CHECK_MACRO_IF_IS_ENABLED(wxT("GENERATE_DSYM"), decl);

	//wxPrintf(wxString(wxT("Project '")) + this->GetName()  + wxT("' compiling... ") + wxT("\n"));

	//CommandDescriptorArray s_linkCommandList;
	//CommandDescriptorArray s_compileCommandList;
	//CommandDescriptorArray compileCommandListUB;//for UnityBuilds


	wxString prjPath = wxFileName(this->GetFileName()).GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR);
	
	// IULIA
	NormalizePath(prjPath);

	wxString workingPath = GetWrokingPath();


	if (!wxFileName::DirExists(workingPath))
	{
		///because the folder does not exist it is a clean build
		forceRecompile = true;

		if (!wxFileName::Mkdir(workingPath, 777, wxPATH_MKDIR_FULL))
		{
			ERROR_PRINTF(sln2gccApp::s_executableFilePath->GetFullName(), wxString(wxT("cannot create folder: ") + workingPath + wxT("\n")));
			sln2gccApp::SetErrorCode(1);
			return false;
		}
	}

	//set the working folder!
	wxFileName::SetCwd(workingPath);


	wxString relativePath = sln2gccApp::GetRelativePath(workingPath, prjPath);

	decl[wxT("PROJECT_PATH")] = prjPath;
	decl[wxT("SRC_PATH")] = relativePath;


	decl[wxT("INCLUDE_PATHS")] = decl[wxT("INCLUDE_PATHS")] + wxT(" $(PROJECT_PATH)\\");



	//analyze each path from INCLUDE_PATHS from project(xml) and transform relative paths in absolute paths!
	//this step seems to be useless because all the paths was recomputed to be relative paths. Probably i will remove this !!!
	//but until that i will check the existance of the paths!
	wxStringTokenizer* tkn = NEW wxStringTokenizer(this->m_projectDecl[wxT("INCLUDE_PATHS")], wxT(" "));
	wxString new_include_paths = wxEmptyString;
	while (tkn->HasMoreTokens())
	{
		wxString newTok = tkn->GetNextToken();
		if (newTok != wxEmptyString)
		{
			newTok.Replace(wxT("\""), wxT(" "));
			newTok.Trim().Trim(false);

			wxString errorsReturned = wxEmptyString;
			//replace macros, but do not remove the macros without values
			newTok = sln2gccApp::ExpandExpression(newTok, this->m_projectDecl, errorsReturned, false);
			//replace macros, but do not remove the macros without values
			newTok = sln2gccApp::ExpandExpression(newTok, decl, errorsReturned, false);

			wxString includePath = newTok;
			if ((!HAVE_MACROS(includePath)) && (wxFileName(includePath).IsRelative()))
			{
				includePath = wxString(wxT("$(PROJECT_PATH)\\")) + includePath;
				//wxPrintf("prj path: %s\n", wxString(wxT(" $(PROJECT_PATH)\\")).c_str());

				//replace macros, but do not remove the macros without values
				includePath = sln2gccApp::ExpandExpression(includePath, decl, errorsReturned, false);
			}

			if (!HAVE_MACROS(includePath))
			{
				//wxFileName includePathFN(includePath);
				//includePathFN.Normalize();//make the path shorter
				//wxString includeRelativePath = includePathFN.GetFullPath();
				//includeRelativePath = includePath;

				//wxPrintf("path1: %s\n", includePath.c_str());

				NormalizePath(includePath);
				wxString includeRelativePath = includePath;

				//wxPrintf("path2: %s\n\n", includeRelativePath.c_str());

				if (wxFileName::DirExists(includeRelativePath))
				{
					new_include_paths += wxString(wxT(" ")) + includeRelativePath;
				}
				else
				{
					wxString file = wxEmptyString;
					if (!IS_FALSE(this->m_s2gFile))
						file = this->m_s2gFile;
					else
						file = sln2gccApp::s_inputFile;

					WARNING_PRINTF(file, wxString(wxT("Project '")) + this->GetName() + wxT("' ")
								+ wxString(wxT("added INCLUDE_PATHS that don't exist: '")
								+ includeRelativePath + wxT("  from  ")
								+ wxFileName::GetCwd() + wxT("  ")
								+ wxT("'! If USE_ADDITIONAL_INCLUDE_DIRECTORIES_FROM_VS=true check, also, the Visual Studio Additional Include Directories values!\n")));
				}
			}

		}
	}

	this->m_projectDecl[wxT("INCLUDE_PATHS")] = new_include_paths;
	delete tkn;



	decl[wxT("INCLUDE_PATHS")] = workingPath + wxT(" ") + this->m_projectDecl[wxT("INCLUDE_PATHS")] + wxT(" ") + decl[wxT("INCLUDE_PATHS")];
	decl[wxT("LINK_PATHS")] = this->m_projectDecl[wxT("LINK_PATHS")] + wxT(" ") + decl[wxT("LINK_PATHS")];
	decl[wxT("DEFINES")] = this->m_projectDecl[wxT("DEFINES")] + wxT(" ") + decl[wxT("DEFINES")];
	decl[wxT("LDLIBS")] = this->m_projectDecl[wxT("LDLIBS")] + wxT(" ") + decl[wxT("LDLIBS")];
	decl[wxT("LDFLAGS")] = decl[wxT("LDFLAGS")] + wxT(" ") + this->m_projectDecl[wxT("LDFLAGS")];
	wxString CFLAGS_DEFAULT = decl[wxT("CFLAGS")] + wxT(" ") + this->m_projectDecl[wxT("CFLAGS")];

	if (generateDsym || generateBreakpadSym)
	{
		if (CFLAGS_DEFAULT.Find(wxT(" -g ")) == wxNOT_FOUND)
			CFLAGS_DEFAULT += wxT(" -g ");
	}

	wxString cleanInclude = decl[wxT("INCLUDE_PATHS")];
	REPLACE_SEPARATORS_WITH_SPACE(cleanInclude);
	decl[wxT("INCLUDE_PATHS")] = cleanInclude;

	//add -I in front of each path INCLUDE_PATHS
	tkn = NEW wxStringTokenizer(decl[wxT("INCLUDE_PATHS")], wxT(" "));
	new_include_paths = wxEmptyString;
	while (tkn->HasMoreTokens())
	{
		wxString newTok = tkn->GetNextToken();

		if (newTok != wxEmptyString)
		{

			//PRINTF(COLOR_RED, newTok + wxT("\n"));
			wxString errorMsg = wxEmptyString;

			//replace macros, but do not remove the macros without values
			newTok = sln2gccApp::ExpandExpression(newTok, this->m_projectDecl, errorMsg, false);
			//replace macros, but do not remove the macros without values
			newTok = sln2gccApp::ExpandExpression(newTok, decl, errorMsg, false);

			//PRINTF(COLOR_GREEN, "%i    %s\n", wxFileName(newTok).IsAbsolute(wxPATH_NATIVE), newTok.c_str());

			//TODO transform the absolute paths to relative paths because the command line must be small     
			if ((!HAVE_MACROS(newTok)) && wxFileName(newTok).IsAbsolute(wxPATH_NATIVE))
			{
				//wxString newTokRelative = sln2gccApp::GetRelativePath(GetWrokingPath(), newTok + SEP);
				//if (newTokRelative != wxEmptyString)
				//	newTok = newTokRelative;
			}

			//PRINTF(COLOR_YELLOW, newTok + wxT("\n"));

			//check if this path was added already.
			if ((newTok != wxEmptyString) && !(new_include_paths.Contains(wxT(" -I") + newTok + wxT(" "))))
			{
				new_include_paths += wxT(" -I") + newTok;
			}
		}
	}
	decl[wxT("INCLUDE_PATHS")] = new_include_paths;
	delete tkn;


	//add -L in front of each path from LINK_PATHS
	tkn = NEW wxStringTokenizer(decl[wxT("LINK_PATHS")], wxT(" "));
	wxString new_link_paths = wxEmptyString;
	while (tkn->HasMoreTokens())
	{
		wxString newTok = tkn->GetNextToken();
		//check if this path was added already.
		if ((newTok != wxEmptyString) && !(new_link_paths.Contains(wxT(" -L") + newTok + wxT(" "))))
			new_link_paths += wxT(" -L") + newTok;

	}

	// if at least one compiled library was used
	// we need to add the compiled libraries directory
	// to link paths
	if (isMainProject &&
		s_atLeastOneCompiledLibUsed)
	{
		wxString compiledLibsLink = wxEmptyString;

		compiledLibsLink += wxT(" -L../../../");

		if (sln2gccApp::s_typeOfBuild == STR_DEBUG)
		{

		}
		else if (sln2gccApp::s_typeOfBuild == STR_RELEASE)
		{

		}
		else
		{
			PRINTF(COLOR_RED, wxT("This should never happen! Type of build(%s) must be either 'debug' or 'release'"), sln2gccApp::s_typeOfBuild);
		}

		compiledLibsLink = wxT("-L") + sln2gccApp::s_precompiledPath + SEP + sln2gccApp::s_typeOfBuild + SEP + sln2gccApp::s_gccConfig;
		//compiledLibsLink += sln2gccApp::s_typeOfBuild + wxT("Libs") + SEP + sln2gccApp::s_gccConfig;

		new_link_paths = compiledLibsLink + SEP + new_link_paths;
		//wxPrintf("\n\ncompiledLibsLink: %s\n\n", compiledLibsLink.c_str());
	}

	decl[wxT("LINK_PATHS")] = new_link_paths;
	delete tkn;


	//add -D in front of each path from DEFINES
	tkn = NEW wxStringTokenizer(decl[wxT("DEFINES")], wxT(" "));
	wxString new_defines = wxEmptyString;
	while (tkn->HasMoreTokens())
	{
		wxString newTok = tkn->GetNextToken();
		if (newTok != wxEmptyString)
		{
			new_defines += wxT(" -D") + newTok;
		}
	}
	decl[wxT("DEFINES")] = new_defines;
	delete tkn;



	///////////////////////////////////////////////////
	//CUSTOM unity buids
#pragma region CustomUnityBuilds

	for (unsigned int i = 0; i < m_customUBFiles.size(); i++)
	{
		CustomUnityBuild* cub = m_customUBFiles[i];

		//wxPrintf(wxT("Create cub->m_name=") + cub->m_name + wxT(", i=%d\n"), i);

		if (cub->m_files.size() == 0)
		{
			WARNING_PRINTF(wxString(wxT("file")), wxT("Custom Unity Build '") + cub->m_name + wxT("' does not contains any valid source files! \n"));
			delete cub;
			m_customUBFiles.RemoveAt(i);
			i--;
			continue;
		}

		bool alreadyExists = false;
		wxFile *unityFile = NULL;
		bool openOK = false;
		wxString unityFileName = wxEmptyString;
		wxString unityFileNameTemp = wxEmptyString;
		wxString unityFileNameUsed = wxEmptyString;

		unityFileName = unityFileName.Format(cub->m_name);
		unityFileNameTemp = unityFileName + wxT("_temp");


		if (!wxFileName::FileExists(unityFileName))
		{
			unityFileNameUsed = unityFileName;
			alreadyExists = false;
		}
		else
		{
			unityFileNameUsed = unityFileNameTemp;
			alreadyExists = true;
		}


		unityFile = NEW wxFile(unityFileNameUsed, wxFile::write);
		openOK = unityFile->Create(unityFileNameUsed, true);

		if (unityFile)
		{
			if (openOK)
			{
				wxString str = wxEmptyString;

				for (unsigned int j = 0; j < cub->m_files.size(); j++)
				{
					wxString sFile = cub->m_files[j];

					if (!wxFileName(sFile).IsAbsolute())
					{
						sFile = prjPath + SEP + sFile;
					}

					str = wxString(wxT("#include \"")) + sFile + wxT("\"\n");
					if (!unityFile->Write(str))
					{
						WARNING_PRINTF(wxString(wxT("file")), wxT("Cannot write string '") + str + wxT("' in the file '") + unityFileNameUsed + wxT("'\n"));
					}
				}
			}
			else
			{
				WARNING_PRINTF(wxString(wxT("file")), wxT("Cannot create file ") + unityFileNameUsed + wxT("\n"));
			}
		}



		CloseAndRenameCurrentAUB(unityFile, unityFileName, unityFileNameTemp, alreadyExists);
		/*unityFile->Flush();
		unityFile->Close();
		delete unityFile;
		unityFile = NULL;

		//wxPrintf(wxT("Close1 unityFileNameUsed=") + unityFileNameUsed + wxT("\n"));

		if(alreadyExists)
		{
		if(!CompareFiles(unityFileName, unityFileNameTemp))
		{
		//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' DIFFERS\n"));
		::wxRenameFile(unityFileNameTemp, unityFileName, true);
		}
		else
		{
		//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' The same!\n"));
		}
		}*/

		//wxPrintf(wxT("Create cub->m_name=") + cub->m_name + wxT("\n"));
		this->m_sourceFiles.Insert(workingPath + SEP + cub->m_name, 0);
	}
#pragma endregion



	///////////////////////////////////////////////////
	//GENERATE unity buids
#pragma region GenerateUnityBuilds

	int unityBuildsFilesPerUnit = 0;
	int unityBuildsFilesPerUnitC = 0;
	int unityBuildsFilesPerUnitCPP = 0;
	int unityBuildsForC = 0;
	int unityBuildsForCPP = 0;
	int cFiles = 0;
	int cppFiles = 0;
	if (m_autoGeneratedUBNumber > 0)
	{
		////// calculate number of c and cpp files that must be added to UB
		int filesNo = this->m_sourceFiles.size();
		for (int i = 0; i < filesNo; i++)
		{
			///exclude files ////
			if (IsExcludedFromUnityBuild(this->m_sourceFiles[i])) continue;
			///exclude files ////

			if (wxFileName(this->m_sourceFiles[i]).GetExt() == wxT("cpp")) cppFiles++;
			if (wxFileName(this->m_sourceFiles[i]).GetExt() == wxT("c")) cFiles++;
		}
		//////////

		if ((cFiles + cppFiles) > 0)
		{
			unityBuildsForC = (cFiles / (cFiles + cppFiles)) * m_autoGeneratedUBNumber;
			if ((cFiles > 0) && (unityBuildsForC < 1)) unityBuildsForC = 1;


			unityBuildsForCPP = m_autoGeneratedUBNumber - unityBuildsForC;

			if (unityBuildsForC > 0)
				unityBuildsFilesPerUnitC = cFiles / unityBuildsForC + (((cFiles%unityBuildsForC) == 0) ? 0 : 1);

			if (unityBuildsForCPP > 0)
				unityBuildsFilesPerUnitCPP = cppFiles / unityBuildsForCPP + (((cppFiles%unityBuildsForCPP) == 0) ? 0 : 1);

			m_useAutoGeneratedUnityBuilds = (m_autoGeneratedUBNumber > 0);

			if (sln2gccApp::GetEnableVerbose())
			{
				wxPrintf(wxT("cFiles=%d, unityBuildsForC=%d, unityBuildsFilesPerUnitC=%d\n"), cFiles, unityBuildsForC, unityBuildsFilesPerUnitC);
				wxPrintf(wxT("cppFiles=%d, unityBuildsForCPP=%d, unityBuildsFilesPerUnitCPP=%d\n"), cppFiles, unityBuildsForCPP, unityBuildsFilesPerUnitCPP);
			}
		}
	}

	if (m_useAutoGeneratedUnityBuilds)
	{
		int unityBuildsCount = 0;
		int filesInCurrentUB = 0;

		wxString unityFileName = wxEmptyString;
		wxString unityFileNameTemp = wxEmptyString;
		wxString unityFileNameUsed = wxEmptyString;

		wxFile *unityFile = NULL;
		bool openOK = false;


		for (unsigned int k = 0; k < this->m_typesOfFilesToBeCompiled.size(); k++)
		{
			wxString currentExtension = m_typesOfFilesToBeCompiled[k];
			if (currentExtension == wxT("c")) unityBuildsFilesPerUnit = unityBuildsFilesPerUnitC;
			else
				if (currentExtension == wxT("cpp")) unityBuildsFilesPerUnit = unityBuildsFilesPerUnitCPP;
				else
					continue; ///create UB only for c and cpp files.

			filesInCurrentUB = 0;

			bool alreadyExists = false;

			//int filesNo = this->m_sourceFiles.size();
			for (unsigned int i = 0; i < this->m_sourceFiles.size(); i++)
			{
				if ((wxFileName(this->m_sourceFiles[i]).GetExt() != currentExtension) ///if differs from the current extension
					|| (IsExcludedFromUnityBuild(this->m_sourceFiles[i])))///if this file is excluded from AUB
				{
					if (i == (this->m_sourceFiles.size() - 1)) ///if this is the last file -> Close the current AUB (AUB = Auto Generated Unity Build)
					{
						CloseAndRenameCurrentAUB(unityFile, unityFileName, unityFileNameTemp, alreadyExists);
					}
					continue;
				}




				if (filesInCurrentUB == 0)
				{
					unityFileName = unityFileName.Format(wxString(wxT("AUB_")) + this->GetName() + wxT("_%d.") + currentExtension, unityBuildsCount);

					unityFileNameTemp = unityFileName + wxT("_temp");

					//wxPrintf(wxT("unityFileName=") + unityFileName + wxT("\n"));


					if (!unityFile)
					{
						//wxPrintf(wxT("=== ") + unityFileName + wxT("----------------------------------\n"));
						if (!wxFileName::FileExists(unityFileName))
						{
							unityFileNameUsed = unityFileName;
							alreadyExists = false;
						}
						else
						{
							unityFileNameUsed = unityFileNameTemp;
							alreadyExists = true;
						}


						unityFile = NEW wxFile(unityFileNameUsed, wxFile::write);
						openOK = unityFile->Create(unityFileNameUsed, true);
						if (openOK)
						{
							m_allUBFiles.Add(unityFileName);
							unityBuildsCount++;

							if (sln2gccApp::GetEnableVerbose())
								wxPrintf(wxT("Create unityFileName=") + unityFileNameUsed + wxT("\n"));
						}
						//if(openOK && sln2gccApp::s_verbose) wxPrintf(wxT("Create unityFileName=") + unityFileNameUsed + wxT("\n"));
						//if(openOK) wxPrintf(wxT("Create unityFileName=") + unityFileNameUsed + wxT("\n"));
					}
					else
					{
						CloseAndRenameCurrentAUB(unityFile, unityFileName, unityFileNameTemp, alreadyExists);
						/*if(unityFile)
						{
						unityFile->Flush();
						unityFile->Close();
						delete unityFile;
						unityFile = NULL;

						//wxPrintf(wxT("Close1 unityFileNameUsed=") + unityFileNameUsed + wxT("\n"));

						if(alreadyExists)
						{
						if(!CompareFiles(unityFileName, unityFileNameTemp))
						{
						//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' DIFFERS\n"));
						::wxRenameFile(unityFileNameTemp, unityFileName, true);
						}
						else
						{
						//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' The same!\n"));
						}
						}

						}*/
					}
				}

				//wxPrintf(wxT("src=") + wxFileName(this->m_sourceFiles[i]).GetFullName() + wxT("\n"));

				///write the #include "path_file_name"
				if (unityFile)
				{
					if (openOK)
					{
						wxString str = wxEmptyString;

						wxString sFile = m_sourceFiles[i];
						if (!wxFileName(sFile).IsAbsolute())
						{
							sFile = prjPath + SEP + m_sourceFiles[i];
						}

						str = wxString(wxT("#include \"")) + sFile + wxT("\"\n");
						if (!unityFile->Write(str))
						{
							WARNING_PRINTF(wxString(wxT("file")), wxT("Cannot write string '") + str + wxT("' in the file '") + unityFileNameUsed + wxT("'\n"));
						}
					}
					else
					{
						WARNING_PRINTF(wxString(wxT("file")), wxT("Cannot create file ") + unityFileNameUsed + wxT("\n"));
					}
				}

				filesInCurrentUB++;
				if ((filesInCurrentUB == unityBuildsFilesPerUnit) || (i == (this->m_sourceFiles.size() - 1)))
				{
					//m_allUBFiles.Add(unityFileName);
					//wxPrintf(wxT("-- ") + unityFileName + wxT("\n"));
					//unityBuildsCount++;
					filesInCurrentUB = 0;

					CloseAndRenameCurrentAUB(unityFile, unityFileName, unityFileNameTemp, alreadyExists);
					/*if(unityFile)
					{
					unityFile->Flush();
					unityFile->Close();
					delete unityFile;
					unityFile = NULL;

					//wxPrintf(wxT("Close2 unityFileNameUsed=") + unityFileNameUsed + wxT("\n"));

					if(alreadyExists)
					{
					if(!CompareFiles(unityFileName, unityFileNameTemp))
					{
					//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' DIFFERS\n"));
					::wxRenameFile(unityFileNameTemp, unityFileName, true);
					}
					else
					{
					//WARNING_PRINTF(wxString(wxT("file")), wxT("Compare files: '") + unityFileName + wxT("' with file '") + unityFileNameTemp + wxT("' The same!\n"));
					}
					}
					}*/
				}

				m_sourceFiles.RemoveAt(i);
				i--;
			}
		}

		//insert UnityBuilds files in to the file list
		int filesNo = m_allUBFiles.size();
		if (filesNo > 0)
		{
			for (int i = 0; i < filesNo; i++)
			{
				this->m_sourceFiles.Insert(m_allUBFiles[i], 0);
				//this->m_sourceFiles.Add(m_allUBFiles[i]);
			}
		}
		else
		{
			m_useAutoGeneratedUnityBuilds = false;
		}

	}
#pragma endregion
	///////////////////////////////////////////////////






	wxString INCLUDE_PATHS_DEFAULT = decl[wxT("INCLUDE_PATHS")];

	bool mustBeRelinked = false;




	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//create the commands to compile the headers for precompiled headers ----------------------------
	wxString objs = wxEmptyString;
	int filesNo = this->m_headerFiles.size();
	int noFilesToRecompile = 0;
	wxString pchFile = wxEmptyString;
	if (filesNo > 0)
	{
		wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' checking headers dependencies... "));
	}


	for (int i = 0; i < filesNo; i++)
	{
		wxYield();
		wxPrintf(wxString(wxT("\rProject '")) + this->GetName() + wxT("' checking headers dependencies... %d/%d"), i + 1, filesNo);

		decl[wxT("INCLUDE_PATHS")] = INCLUDE_PATHS_DEFAULT; ///reset to default

		wxString sourceFile = wxEmptyString;


		if (!wxFileName(m_headerFiles[i]).IsAbsolute())
		{
			sourceFile = prjPath + SEP + m_headerFiles[i];
		}
		else
		{
			sourceFile = m_headerFiles[i];
		}

		wxFileName srcFN(sourceFile);
		srcFN.Normalize();
		srcFN.SetVolume(srcFN.GetVolume().Upper());

		decl[wxT("SRC_FILE")] = srcFN.GetFullPath();

		if (pchFile == wxEmptyString)
		{
			pchFile = decl[wxT("SRC_FILE")];
		}


		wxString objFileName = srcFN.GetFullName() + wxT(".gch");
		wxString depFileName = srcFN.GetFullName() + wxT(".d");
		decl[wxT("OBJ_FILE")] = workingPath + SEP + objFileName;
		decl[wxT("DEP_FILE")] = workingPath + SEP + depFileName;
		objs += wxString(wxT(" ")) + objFileName;

		///this was added to support speciffic compile flags for each file
		decl[wxT("CFLAGS")] = CFLAGS_DEFAULT + wxT(" -x ") + m_projectDecl[wxT("USE_PCH_FILE_AS")] + wxT(" ") + this->m_fileSpecificCFLAGS[srcFN.GetFullName()];
		//wxPrintf(wxString(wxT("FileSpecific file=")) + srcFN.GetFullName() + wxT(" specificCFLAGS=") + this->m_fileSpecificCFLAGS[srcFN.GetFullName()] + wxT("\n"));

		///check if the current src file must be recompiled!
		wxString lastCompileCommand = wxEmptyString;
		bool mustBeRecompiled = forceRecompile;
		//wxPrintf(wxT("1mustBeRecompiled=%d\n"), mustBeRecompiled);
		wxString temp = decl[wxT("DEP_FILE")];
		if (!mustBeRecompiled && wxFileName::FileExists(decl[wxT("DEP_FILE")]))
		{
			wxTextFile dependencyFile(decl[wxT("DEP_FILE")]);
			if (dependencyFile.Open())
			{
				int lines = dependencyFile.GetLineCount();
				if (lines > 0)
				{
					int k = 0;

					lastCompileCommand = dependencyFile[k];
					//wxPrintf(wxT("lastCompileCommand=")+ lastCompileCommand + wxT("\n"));

					if (lastCompileCommand.IndexOf(';') == wxNOT_FOUND)
					{
						k = 1; ///skip the first line has because has the compile command
					}
					else
					{
						lastCompileCommand = wxEmptyString;
					}

					for (; k < lines; k++)
					{
						wxString line = dependencyFile[k];

						line.Trim().Trim(false);
						//wxPrintf(wxT("line=") + line + wxT("\n"));

						int pos = line.IndexOf(';');
						if (pos == wxNOT_FOUND)
						{
							///there is an error on this file so
							///this is a wrong header!
							mustBeRecompiled = true;

							break;
						}

						long tStamp;
						line.Mid(0, pos).ToLong(&tStamp);
						wxString fName = line.Mid(pos + 1);

						if (sln2gccApp::s_fileChangedMap[fName] != FILE_CHANGED_NOT_SET)
						{
							if (sln2gccApp::s_fileChangedMap[fName] == FILE_CHANGED) //wxT("changed")
							{
								mustBeRecompiled = true;
								//wxPrintf(wxT("3mustBeRecompiled=%d\n"), mustBeRecompiled);
								break;
							}
						}
						else
							if (wxFileName::FileExists(fName))
							{
								wxFileName fname(fName);
								long fileTimeStamp = fname.GetModificationTime().GetAsDOS();

								//wxPrintf(wxT("fName=")+ fName + wxT(" %ld, %ld\n"), fileTimeStamp, tStamp);
								if (fileTimeStamp != tStamp)
								{
									sln2gccApp::s_fileChangedMap[fName] = FILE_CHANGED;//wxT("changed");
									mustBeRecompiled = true;
									//wxPrintf(wxT("4mustBeRecompiled=%d\n"), mustBeRecompiled);
									break;
								}
								//c78 - bug fixed by Radu Ruse (bug: after some files are compiled if the compile process is interrupted, the next compile action will not detect the uncompiled files)
								//else
								//{
								//    sln2gccApp::s_fileChangedMap[fName] = FILE_CHANGED_NOT;//wxT("NOTchanged");
								//}
								//c78 - bug fixed by Radu Ruse (bug: after some files are compiled if the compile process is interrupted, the next compile action will not detect the uncompiled files)
							}
							else
							{
								mustBeRecompiled = true;
								//wxPrintf(wxT("5mustBeRecompiled=%d\n"), mustBeRecompiled);
								break;
							}
					}
				}
				else
				{
					mustBeRecompiled = true;
					//wxPrintf(wxT("6mustBeRecompiled=%d\n"), mustBeRecompiled);
				}

			}

			dependencyFile.Close();
		}
		else
		{
			mustBeRecompiled = true;
			//wxPrintf(wxT("7mustBeRecompiled=%d\n"), mustBeRecompiled);
		}

		if (!mustBeRecompiled && !wxFileName::FileExists(decl[wxT("OBJ_FILE")]))
		{
			mustBeRecompiled = true;
			//wxPrintf(wxT("8mustBeRecompiled=%d\n"), mustBeRecompiled);
		}
		///--------------------------------------
		

		wxString inputFile = decl[wxT("SRC_FILE")];
		wxString outputFile = decl[wxT("OBJ_FILE")];
		wxString dependencyFile = decl[wxT("DEP_FILE")];
		wxString compileCommand = wxEmptyString;

		compileCommand = decl[wxT("COMPILE_CPP_COMMAND_LINE")];


		wxString errorMsg = wxEmptyString;
		compileCommand = sln2gccApp::ExpandExpression(compileCommand, decl, errorMsg);
		compileCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
		compileCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);
		
		if (lastCompileCommand != compileCommand)
		{

			mustBeRecompiled = true;
			//wxPrintf(wxT("9mustBeRecompiled=%d\n"), mustBeRecompiled);
			//wxPrintf(wxT("\n%s\n!=\n%s\n"), lastCompileCommand, compileCommand);
		}

		if (mustBeRecompiled)
		{
			noFilesToRecompile++;

			//wxPrintf(wxT("wxFileName(inputFile).GetFullName()=") + wxFileName(inputFile).GetFullName() + wxT("\n"));

			CommandDescriptor* ccd = NULL;

			compileCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
			compileCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);
			ccd = NEW CompileCommandDescriptor(inputFile, dependencyFile, outputFile, workingPath, compileCommand, false, wxString(wxT("Compile pch: ")) + wxFileName(inputFile).GetFullName() + wxString(wxT("\t\tfrom '")) + this->GetName() + wxT("' "));

			s_compileCommandList.insert(s_compileCommandList.begin(), ccd);
			fileChanged++;
		}
	}
	if (filesNo > 0)
		wxPrintf(wxT("\n"));
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------



	wxFile* compileCommandsFile = NEW wxFile(COMPILE_COMMANDS_FILE, wxFile::write);
	bool compileCommandsFileOK = compileCommandsFile->Create(COMPILE_COMMANDS_FILE, true);



	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//create the commands to compile the sources-----------------------------------------------------
	wxPrintf(wxString(wxT("Project '")) + this->GetName() + wxT("' checking src dependencies... "));

	objs = wxEmptyString;
	filesNo = this->m_sourceFiles.size();
	noFilesToRecompile = 0;
	for (int i = 0; i < filesNo; i++)
	{
		wxYield();
		wxPrintf(wxString(wxT("\rProject '")) + this->GetName() + wxT("' checking src dependencies... %d/%d"), i + 1, filesNo);

		bool isUnityBuildFile = false;

		if (m_useAutoGeneratedUnityBuilds)
		{
			for (unsigned int p = 0; p < m_allUBFiles.size(); p++)
			{
				if (m_allUBFiles[p] == m_sourceFiles[i])
				{
					isUnityBuildFile = true;
					break;
				}
			}
		}



		decl[wxT("INCLUDE_PATHS")] = INCLUDE_PATHS_DEFAULT; ///reset to default

		wxString sourceFile = wxEmptyString;

		if (m_useAutoGeneratedUnityBuilds && isUnityBuildFile)
		{
			sourceFile = m_sourceFiles[i];
		}
		else
		{
			if (!wxFileName(m_sourceFiles[i]).IsAbsolute())
			{
				sourceFile = prjPath + SEP + m_sourceFiles[i];
			}
			else
			{
				sourceFile = m_sourceFiles[i];
			}
		}


		wxFileName srcFN(sourceFile);
		srcFN.Normalize();
		srcFN.SetVolume(srcFN.GetVolume().Upper());

		decl[wxT("SRC_FILE")] = srcFN.GetFullPath();


		wxString objFileName = srcFN.GetName() + wxT(".o");
		wxString depFileName = srcFN.GetName() + wxT(".d");
		decl[wxT("OBJ_FILE")] = workingPath + SEP + objFileName;
		decl[wxT("DEP_FILE")] = workingPath + SEP + depFileName;
		objs += wxString(wxT(" ")) + objFileName;

		///this was added to support speciffic compile flags for each file
		wxString addPCH = wxT(" ");
		if (pchFile != wxEmptyString)
			addPCH = wxT(" -include ") + pchFile + wxT(" ");

		decl[wxT("CFLAGS")] = CFLAGS_DEFAULT + addPCH + this->m_fileSpecificCFLAGS[srcFN.GetFullName()];
		//wxPrintf(decl[wxT("CFLAGS")] +  wxT("\n"));
		//wxPrintf(wxString(wxT("FileSpecific file=")) + srcFN.GetFullName() + wxT(" specificCFLAGS=") + this->m_fileSpecificCFLAGS[srcFN.GetFullName()] + wxT("\n"));

		///check if the current src file must be recompiled!
		wxString lastCompileCommand = wxEmptyString;
		bool mustBeRecompiled = forceRecompile;
		//wxPrintf(wxT("1mustBeRecompiled=%d\n"), mustBeRecompiled);
		if (!mustBeRecompiled && wxFileName::FileExists(decl[wxT("DEP_FILE")]))
		{
			wxTextFile dependencyFile(decl[wxT("DEP_FILE")]);
			if (dependencyFile.Open())
			{
				int lines = dependencyFile.GetLineCount();
				if (lines > 0)
				{
					int k = 0;

					lastCompileCommand = dependencyFile[k];
					//wxPrintf(wxT("lastCompileCommand=")+ lastCompileCommand + wxT("\n"));

					if (lastCompileCommand.IndexOf(';') == wxNOT_FOUND)
					{
						k = 1; ///skip the first line has because has the compile command
					}
					else
					{
						lastCompileCommand = wxEmptyString;
					}

					for (; k < lines; k++)
					{
						wxString line = dependencyFile[k];

						line.Trim().Trim(false);
						//wxPrintf(wxT("line=") + line + wxT("\n"));

						int pos = line.IndexOf(';');
						if (pos == wxNOT_FOUND)
						{
							///there is an error on this file so
							///this is a wrong header!
							mustBeRecompiled = true;

							break;
						}

						long tStamp;
						line.Mid(0, pos).ToLong(&tStamp);
						wxString fName = line.Mid(pos + 1);

						if (sln2gccApp::s_fileChangedMap[fName] != FILE_CHANGED_NOT_SET)
						{
							if (sln2gccApp::s_fileChangedMap[fName] == FILE_CHANGED) //wxT("changed")
							{
								mustBeRecompiled = true;
								//wxPrintf(wxT("3mustBeRecompiled=%d\n"), mustBeRecompiled);
								break;
							}
						}
						else
							if (wxFileName::FileExists(fName))
							{
								wxFileName fname(fName);
								long fileTimeStamp = fname.GetModificationTime().GetAsDOS();

								//wxPrintf(wxT("fName=")+ fName + wxT(" %ld, %ld\n"), fileTimeStamp, tStamp);
								if (fileTimeStamp != tStamp)
								{
									sln2gccApp::s_fileChangedMap[fName] = FILE_CHANGED;//wxT("changed");
									mustBeRecompiled = true;
									//wxPrintf(wxT("4mustBeRecompiled=%d\n"), mustBeRecompiled);
									break;
								}
								//c78 - bug fixed by Radu Ruse (bug: after some files are compiled if the compile process is interrupted, the next compile action will not detect the uncompiled files)
								//else
								//{
								//    sln2gccApp::s_fileChangedMap[fName] = FILE_CHANGED_NOT;//wxT("NOTchanged");
								//}
								//c78 - bug fixed by Radu Ruse (bug: after some files are compiled if the compile process is interrupted, the next compile action will not detect the uncompiled files)
							}
							else
							{
								mustBeRecompiled = true;
								//wxPrintf(wxT("5mustBeRecompiled=%d\n"), mustBeRecompiled);
								break;
							}
					}
				}
				else
				{
					mustBeRecompiled = true;
					//wxPrintf(wxT("6mustBeRecompiled=%d\n"), mustBeRecompiled);
				}

			}

			dependencyFile.Close();
		}
		else
		{
			mustBeRecompiled = true;
			//wxPrintf(wxT("7mustBeRecompiled=%d\n"), mustBeRecompiled);
		}

		if (!mustBeRecompiled && !wxFileName::FileExists(decl[wxT("OBJ_FILE")]))
		{
			mustBeRecompiled = true;
			//wxPrintf(wxT("8mustBeRecompiled=%d\n"), mustBeRecompiled);
		}
		///--------------------------------------



		wxString inputFile = decl[wxT("SRC_FILE")];
		wxString outputFile = decl[wxT("OBJ_FILE")];
		wxString dependencyFile = decl[wxT("DEP_FILE")];
		wxString compileCommand = wxEmptyString;


		if (srcFN.GetExt() == wxT("cpp")
			|| srcFN.GetExt() == wxT("cc")
			|| srcFN.GetExt() == wxT("cxx")
			|| srcFN.GetExt() == wxT("C"))///for cpp files
		{
			compileCommand = decl[wxT("COMPILE_CPP_COMMAND_LINE")];
		}
		else ///for c files or other type of files.
		{
			compileCommand = decl[wxT("COMPILE_CC_COMMAND_LINE")];
		}


		wxString errorMsg = wxEmptyString;
		compileCommand = sln2gccApp::ExpandExpression(compileCommand, decl, errorMsg);
		compileCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
		compileCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);
		

		if (lastCompileCommand != compileCommand)
		{
			mustBeRecompiled = true;
			//wxPrintf(wxT("9mustBeRecompiled=%d\n"), mustBeRecompiled);
			//wxPrintf(wxT("\n%s\n!=\n%s\n"), lastCompileCommand, compileCommand);
		}

		if (mustBeRecompiled)
		{
			noFilesToRecompile++;

			//wxPrintf(wxT("wxFileName(inputFile).GetFullName()=") + wxFileName(inputFile).GetFullName() + wxT("\n"));

			CommandDescriptor* ccd = NULL;


			compileCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
			compileCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);

			wxString label1 = wxString(wxT("Compile: ")) + wxFileName(inputFile).GetFullName();
			for (int i = label1.length(); i < 40; i++)
				label1 += " ";
			wxString label = label1 + wxString(wxT("\tfrom '")) + this->GetName() + wxT("' ");

			ccd = NEW CompileCommandDescriptor(inputFile, dependencyFile, outputFile, workingPath, compileCommand, false, label);

			if (compileCommandsFileOK)
			{
				compileCommandsFile->Write(compileCommand + wxT("\n"));
			}

			s_compileCommandList.push_back(ccd);
			fileChanged++;

		}
	}

	if (compileCommandsFileOK)
	{
		compileCommandsFile->Flush();
		compileCommandsFile->Close();
	}
	delete compileCommandsFile;

	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------





	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	decl[wxT("OBJ_FILES")] = objs;

	wxString targetFile = decl[wxT("OUT")];

	wxString linkCommand = wxEmptyString;

	if (m_targetOutType == wxT("exe"))
	{
		linkCommand = decl[wxT("EXE_LINK_COMMAND_LINE")];
	}
	else
		if (m_targetOutType == wxT("so") || m_targetOutType == wxT("dll"))
		{
			linkCommand = decl[wxT("DYNAMIC_LINK_COMMAND_LINE")];
		}
		else
			if (m_targetOutType == wxT("a") || m_targetOutType == wxT("lib"))
			{
				linkCommand = decl[wxT("STATIC_LINK_COMMAND_LINE")];
			}

	wxString errorMsg = wxEmptyString;
	linkCommand = sln2gccApp::ExpandExpression(linkCommand, decl, errorMsg);
	linkCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
	linkCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);

	LinkCommandDescriptor* currentLinkCommand = NEW LinkCommandDescriptor(linkCommand, targetFile, workingPath, wxString(wxT("Link: ")) + targetFile, isMainProject);
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	DsymCommandDescriptor* currentGBPDsymCommand = NULL;
	DsymCommandDescriptor* currentDsymCommand = NULL;
	StripCommandDescriptor* currentStripCommand = NULL;
	if (isMainProject && (generateDsym || generateBreakpadSym))
	{
		decl[wxT("INPUT")] = decl[wxT("OUT")];

		if (generateDsym)
		{
			decl[wxT("OUT")] = wxFileName(decl[wxT("INPUT")]).GetName() + wxT(".dsym");

			wxString dsymCommand = decl[wxT("DSYM_COMMAND_LINE")];

			errorMsg = wxEmptyString;
			dsymCommand = sln2gccApp::ExpandExpression(dsymCommand, decl, errorMsg);
			dsymCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
			dsymCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);

			currentDsymCommand = NEW DsymCommandDescriptor(dsymCommand, decl[wxT("INPUT")], workingPath, wxString(wxT("Generate DSYM: ")) + decl[wxT("OUT")]);
		}

		if (generateBreakpadSym)
		{
			decl[wxT("OUT")] = wxFileName(decl[wxT("INPUT")]).GetName() + wxT(".sym");

			wxString dsymCommand = decl[wxT("BREAKPAD_SYM_COMMAND_LINE")];

			errorMsg = wxEmptyString;
			dsymCommand = sln2gccApp::ExpandExpression(dsymCommand, decl, errorMsg);
			dsymCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
			dsymCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);

			//PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("\ndsymCommand= '")) + dsymCommand  + wxT("'!\n"));
			currentGBPDsymCommand = NEW DsymCommandDescriptor(dsymCommand, decl[wxT("INPUT")], workingPath, wxString(wxT("Generate Google Breakpad SYM: ")) + decl[wxT("OUT")]);
		}


		if ((sln2gccApp::s_typeOfBuild == STR_DEBUG) && (CHECK_MACRO_IF_IS_ENABLED(wxT("STRIP_DEBUG_SYMBOLS_FOR_DEBUG"), decl))
			|| (sln2gccApp::s_typeOfBuild == STR_RELEASE) && (CHECK_MACRO_IF_IS_ENABLED(wxT("STRIP_DEBUG_SYMBOLS_FOR_RELEASE"), decl)))
		{
			wxString stripCommand = decl[wxT("STRIP_COMMAND_LINE")];

			errorMsg = wxEmptyString;
			stripCommand = sln2gccApp::ExpandExpression(stripCommand, decl, errorMsg);
			stripCommand.Replace(sln2gccApp::msc_backslash, sln2gccApp::msc_slash);
			stripCommand.Replace(sln2gccApp::msc_doubleSlash, sln2gccApp::msc_slash);

			currentStripCommand = NEW StripCommandDescriptor(stripCommand, decl[wxT("INPUT")], workingPath, wxString(wxT("Strip: ")) + decl[wxT("INPUT")]);
		}
	}
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------


	if (fileChanged > 0)
	{
		wxPrintf(wxString(wxT("\nProject '")) + this->GetName() + wxT("' changed %d file(s)\n"), fileChanged);

		mustBeRelinked = true;
	}
	else
	{
		PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("\nProject '")) + this->GetName() + wxT("' all files already compiled!\n"));
	}




	if (!mustBeRelinked && (!wxFileName::FileExists(currentLinkCommand->GetTarget())))
	{
		mustBeRelinked = true;
	}



	wxTextFile linkCommandsFile(LINK_COMMANDS_FILE);
	bool linkCommandsFileOK = false;
	if (linkCommandsFile.Exists())
		linkCommandsFileOK = linkCommandsFile.Open();
	else
		linkCommandsFileOK = linkCommandsFile.Create();
	wxString linkCommandOld = wxEmptyString;
	if (linkCommandsFileOK && linkCommandsFile.GetLineCount())
	{
		linkCommandOld = linkCommandsFile[0];
		linkCommandsFile.Clear();
	}
	if (linkCommandsFileOK)
	{
		linkCommandsFile.AddLine(currentLinkCommand->m_linkCommand + wxT("\n"));
		linkCommandsFile.Write();
		linkCommandsFile.Close();
	}

	//wxPrintf(linkCommandOld.Trim().Trim(false) + wxT("\n"));
	//wxPrintf(currentLinkCommand->m_linkCommand.Trim().Trim(false) + wxT("\n"));

	if ((!mustBeRelinked) && (linkCommandOld.Trim().Trim(false) != currentLinkCommand->m_linkCommand.Trim().Trim(false)))
	{
		mustBeRelinked = true;
	}



	if (mustBeRelinked || forceRelink)
	{
		s_linkCommandList.push_back(currentLinkCommand);

		if (currentGBPDsymCommand != NULL)
			s_linkCommandList.push_back(currentGBPDsymCommand);

		if (currentDsymCommand != NULL)
			s_linkCommandList.push_back(currentDsymCommand);

		if (currentStripCommand != NULL)
			s_linkCommandList.push_back(currentStripCommand);

		m_targetChanged = true; ///the target it is changed if the project has linked
		///the target it is changed if the project has failed the link 
		///so, the library it is changed!!!
	}
	else
	{
		delete currentLinkCommand;
	}

	return true;
}



bool VcProject::Compile()
{
	VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" s_compileCommandList.size = %d\n"), s_compileCommandList.size());

	CommandDescriptor::s_commandsTotalToExecute = s_compileCommandList.size();
	CommandDescriptor::s_commandsExecuted = 0;

	if (CommandDescriptor::s_commandsTotalToExecute > 0)
	{
		wxPrintf(wxString(wxT("\nStart to compile %d file(s)...\n")), CommandDescriptor::s_commandsTotalToExecute);
	}
	else
	{
		PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("\nAll files already compiled!\n")));
	}

	//Search for the first source file that must be compiled.
	//The first commands are the PCH commands. So i need to wait until all PCH are compiled before to compile the sources.
	//To do that, for the first source i set the flag m_waitForAllPrevJobsToEnd=true .
	for (int i = 0; i < CommandDescriptor::s_commandsTotalToExecute; i++)
	{
		CompileCommandDescriptor* command = (CompileCommandDescriptor*)s_compileCommandList[i];
		if (wxFileName(command->m_inputFile).GetExt() != wxT("h"))
		{
			command->m_waitForAllPrevJobsToEnd = true;
			break;
		}
	}


	for (int i = 0; i < CommandDescriptor::s_commandsTotalToExecute; i++)
	{
		//if(sln2gccApp::s_errorsNo >= sln2gccApp::s_errorsNoMax) 
		//{
		//    PRINTF(COLOR_RED, wxT("\nMaximum number of errors (%d) detected!\n"), sln2gccApp::s_errorsNoMax);
		//    return false;
		//}

		CompileCommandDescriptor* command = (CompileCommandDescriptor*)s_compileCommandList[i];

		///limit the number of processes ----------
		bool localCanGetNewJobs = false;
		bool distccCanGetNewJobs = false;
		do
		{
			if (sln2gccApp::GetAbortProgram())
			{
				PRINTF(COLOR_RED, wxT("\nCompile process aborted (by user)!\n"));
				return false;
			}


			if (sln2gccApp::IsDistccEnable())
			{
				//distccCanGetNewJobs = (command->m_command.size() < 1048) && RemoveEndedProcessesFromQueue(s_procDistccArray , sln2gccApp::s_distccJobs);
				distccCanGetNewJobs = RemoveEndedProcessesFromQueue(s_procDistccArray, sln2gccApp::GetDISTCCJobs());
			}

			localCanGetNewJobs = RemoveEndedProcessesFromQueue(s_procLocalArray, sln2gccApp::GetJobj());
		} while (!localCanGetNewJobs && !distccCanGetNewJobs);
		///--------------------------------------------------


		if (command->m_waitForAllPrevJobsToEnd)
		{
			if ((s_procLocalArray.size() > 0) || (s_procDistccArray.size() > 0))
			{
				i--;
				continue;
			}
		}



		if (localCanGetNewJobs)
			command->SetDistcc(wxEmptyString);
		else
			command->SetDistcc(sln2gccApp::s_declarations[wxT("DISTCC")]);

		//if(sln2gccApp::s_enableCcache) command->SetCcache(sln2gccApp::s_declarations[wxT("CCACHE")]);



		///do not delete this pointer - the threads are self deleting pointers.
		ExternalCommandThread* cmdThread = NEW ExternalCommandThread((CommandDescriptor*)command);


		wxThreadError terr = cmdThread->Create();
		if (terr == wxTHREAD_NO_ERROR)
		{
			//wxFileName::SetCwd(command->m_workingDir);
			terr = cmdThread->Run();
			//wxThread::Sleep(10);
		}

		wxYield();

		if (command->m_waitUntilJobEnds)
		{
			while (!command->IsJobEnd())
			{
				wxThread::Sleep(5);
			}
		}



		if (terr != wxTHREAD_NO_ERROR)
		{
			PRINTF(COLOR_RED, _T("Thread Execution failed.\n"));

			delete cmdThread;
		}
		else
		{
			if ((localCanGetNewJobs || !sln2gccApp::IsDistccEnable()))
				s_procLocalArray.push_back(command);
			else
				//if(distccCanGetNewJobs)
				s_procDistccArray.push_back(command);
		}

		wxYield();
	}



	///wait the end of all the running processes ------------
	while (!RemoveEndedProcessesFromQueue(s_procDistccArray, 0));
	while (!RemoveEndedProcessesFromQueue(s_procLocalArray, 0));
	///--------------------------------------------------

	//if(sln2gccApp::s_errorsNo >= sln2gccApp::s_errorsNoMax) 
	//{
	//    PRINTF(COLOR_RED, wxT("\nMaximum number of errors (%d) detected!\n"), sln2gccApp::s_errorsNoMax);
	//    return false;
	//}

	return true;
}
/*
void VcProject::AbortAll()
{
VcProject::Abort(s_procDistccArray);
VcProject::Abort(s_procLocalArray);
}

void VcProject::Abort(CommandDescriptorArray& procArray)
{
for (unsigned int i=0;i<procArray.size(); i++ )
{
CommandDescriptor* cd = procArray[i];

if(cd != NULL)
{
cd->KillAllProcesses();

wxThread::Sleep(100);
}
}
}
*/

bool VcProject::Link()
{
	CommandDescriptor::s_commandsTotalToExecute = s_linkCommandList.size();
	CommandDescriptor::s_commandsExecuted = 0;

	if (CommandDescriptor::s_commandsTotalToExecute > 0)
	{
		wxPrintf(wxString(wxT("\nStart to execute %d link command(s)...\n")), CommandDescriptor::s_commandsTotalToExecute);
	}
	else
	{
		PRINTF(COLOR_BLUE_LIGHT, wxString(wxT("\nAll libs are already linked!\n")));
	}



	for (int i = 0; i < CommandDescriptor::s_commandsTotalToExecute; i++)
	{
		if (sln2gccApp::GetAbortProgram())
		{
			PRINTF(COLOR_RED, wxT("\nLink process aborted (by user)!\n"));
			return false;
		}

		//if(sln2gccApp::s_errorsNo >= sln2gccApp::s_errorsNoMax) 
		//{
		//    PRINTF(COLOR_RED, wxT("\nMaximum number of errors (%d) detected!\n"), sln2gccApp::s_errorsNoMax);
		//    return false;
		//}

		CommandDescriptor* command = s_linkCommandList[i];

		///limit the number of processes ----------
		bool localCanGetNewJobs = false;
		bool distccCanGetNewJobs = false;
		do
		{
			localCanGetNewJobs = RemoveEndedProcessesFromQueue(s_procLocalArray, sln2gccApp::GetJobj());
		} while (!localCanGetNewJobs);
		///--------------------------------------------------

		if (command->m_waitForAllPrevJobsToEnd)
		{
			if ((s_procLocalArray.size() > 0))
			{
				i--;
				continue;
			}
		}

		ExternalCommandThread* cmdThread = NEW ExternalCommandThread((CommandDescriptor*)command);


		wxThreadError terr = cmdThread->Create();
		if (terr == wxTHREAD_NO_ERROR)
		{
			//wxFileName::SetCwd(command->m_workingDir);
			terr = cmdThread->Run();
			//PRINTF(COLOR_YELLOW, wxT("1Target:") + cmdThread->m_cmdDesc->GetLabel() + wxT("\n"));
			//PRINTF(COLOR_YELLOW, wxT("1Working Dir:") + cmdThread->m_cmdDesc->m_workingDir + wxT("\n"));
			wxThread::Sleep(10);
		}

		wxYield();


		if (command->m_waitUntilJobEnds)
		{
			while (!command->IsJobEnd())
			{
				wxThread::Sleep(5);
			}
		}

		if (terr != wxTHREAD_NO_ERROR)
		{
			PRINTF(COLOR_RED, _T("Thread Execution failed.\n"));

			delete cmdThread;
		}
		else
		{

			s_procLocalArray.push_back(command);
		}


		wxYield();
	}



	///wait the end of all the running processes ------------
	while (!RemoveEndedProcessesFromQueue(s_procLocalArray, 0));
	///--------------------------------------------------


	//if(sln2gccApp::s_errorsNo >= sln2gccApp::s_errorsNoMax) 
	//{
	//    PRINTF(COLOR_RED, wxT("\nMaximum number of errors (%d) detected!\n"), sln2gccApp::s_errorsNoMax);
	//    return false;
	//}


	return true;
}


void VcProject::CopyLibs()
{
	int count = s_newlyCompiledLibs.GetCount();

	if (count / 2 == 0)
	{
		PRINTF(COLOR_GREEN, wxT("No new libs needs copying.\n"));
		return;
	}

	PRINTF(COLOR_GREEN, wxT("Copying %d newly created libs...  \n"), count / 2);
	for (int i = 0; i < count; i += 2)
	{
		wxString libName = s_newlyCompiledLibs[i];
		libName = libName.AfterLast('\\');

		PRINTF(COLOR_YELLOW, wxT("    %d/%d copying...\n"), (i / 2) + 1, count / 2);
		PRINTF(COLOR_YELLOW, wxT("from [%s]...\n"), s_newlyCompiledLibs[i]);
		PRINTF(COLOR_YELLOW, wxT("to   [%s]... "), s_newlyCompiledLibs[i + 1]);

		if (wxCopyFile(s_newlyCompiledLibs[i], s_newlyCompiledLibs[i + 1]))
		{
			PRINTF(COLOR_GREEN, wxT("succeded!\n\n"));
		}
		else
		{
			PRINTF(COLOR_RED, wxT("failed!\n"));
		}
	}
}


void VcProject::RemoveFilesFromCompilingQueue(wxString UnityBuildFile, CommandDescriptorArray& compileCommands, LinkCommandDescriptor& linkCommand)
{
	VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" compileCommands.size = %d\n"), compileCommands.size());


	wxTextFile ubfile(UnityBuildFile);
	if (!ubfile.Exists())
	{
		wxPrintf(UnityBuildFile + wxT(" does not EXIST!\n"));
		return;
	}
	if (ubfile.Open())
	{
		int lines = ubfile.GetLineCount();
		//wxPrintf(wxT("lines=%d\n"), lines);

		for (int k = 0; k < lines; k++)
		{
			wxString line = ubfile[k];

			line.Trim().Trim(false);
			//wxPrintf(wxT("line=") + line + wxT("\n"));

			if (line == wxEmptyString) continue;

			int pos = line.IndexOf('"');
			if (pos == wxNOT_FOUND) continue;

			wxString filepath = line.Mid(pos);
			filepath.Replace(wxT("\""), wxT(" "));
			filepath.Trim().Trim(false);
			//wxPrintf(filepath + wxT("\n"));

			for (unsigned int i = 0; i < compileCommands.size(); i++)
			{
				CompileCommandDescriptor* command = (CompileCommandDescriptor*)compileCommands[i];

				wxFileName file1(filepath);
				wxString file1_name = file1.GetFullName();

				wxFileName file2(command->m_inputFile);
				wxString file2_name = file2.GetFullName();
				//wxPrintf(wxT("Compare: ") + file1_name + wxT("==") + file2_name + wxT("\n"));
				if (file1_name == file2_name)
				{
					//wxPrintf(file1_name + wxT("==") + file2_name + wxT("\t\t\tFOUND!!!!!!!!!!!!!!!!!!!!!!\n"));
					compileCommands.erase(compileCommands.begin() + i);
					i = 0;
				}

				wxFileName fntemp(file1_name);
				linkCommand.RemoveObjectFromCommand(wxString(wxT(" ")) + fntemp.GetName() + wxT(".o"));
			}
		}

		ubfile.Close();

	}
	else
	{
		wxPrintf(UnityBuildFile + wxT(" cannot open file!\n"));
	}
}


bool VcProject::CompareFiles(wxTextFile& file1, wxTextFile& file2)
{
	if (!file1.Exists()) return false;
	if (!file2.Exists()) return false;

	if (!file1.Open()) return false;
	if (!file2.Open()) return false;

	bool return_code = true;

	int linesFile1 = file1.GetLineCount();
	int linesFile2 = file2.GetLineCount();

	if (linesFile1 == linesFile2)
	{
		for (int k = 0; k < linesFile1; k++)
		{
			if (file1[k] != file2[k])
			{
				return_code = false;
				break;
			}
		}
	}
	else
	{
		return_code = false;
	}

	file1.Close();
	file2.Close();

	return return_code;
}

bool VcProject::CompareFiles(wxString file1, wxString file2)
{
	wxTextFile file1_(file1);
	wxTextFile file2_(file2);

	return CompareFiles(file1_, file2_);
}



bool VcProject::RemoveEndedProcessesFromQueue(CommandDescriptorArray& procArray, unsigned int processesLeft, bool convertErrorsToWarnings)
{
	VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" procArray.size = %d\n"), procArray.size());


	for (unsigned int i = 0; i < procArray.size(); i++)
	{
		if (sln2gccApp::GetAbortProgram())
			return true;

		CommandDescriptor* cd = procArray[i];
		if (cd != NULL)
		{
			if (cd->IsJobEnd())
			{
				VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" ") + cd->GetLabel() + wxT(" IsJobEnd\n"));

				//if(cd->HasErrors() && cd->GetType() != COMMAND_TYPE_COMPILE_GCH)
				//if(cd->HasErrors() && (((CompileCommandDescriptor*)cd)->m_outputFile.Find(wxT(".h.gch")) == wxNOT_FOUND))
				if (cd->HasErrors())
				{
					sln2gccApp::s_errorsNo++;
				}


				cd->CheckOutput(convertErrorsToWarnings);

				//////////////////////////////////////////////////////////////////////////
				//Memory leak that must be solved!!!
				//delete cd;
				//cd = NULL;
				//////////////////////////////////////////////////////////////////////////
				procArray.erase(procArray.begin() + i);
				i = 0;
			}
			else
				//if(!cd->IsJobEnd())
			{
				VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" ") + cd->GetLabel() + wxT(" !IsJobEnd\n"));

				if (cd->IsStarted())
				{
					VERBOSE(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" ") + cd->GetLabel() + wxT(" IsStarted\n"));

					bool distccEnabledForThisProcess = false;
					if ((sln2gccApp::IsDistccEnable()) && (cd->GetType() == COMMAND_TYPE_COMPILE))
					{
						distccEnabledForThisProcess = ((CompileCommandDescriptor*)cd)->DistccIsEnabled();
					}

					wxTimeSpan elapsedTime = wxDateTime::UNow().Subtract(cd->GetStartTime());
					int elapsedMinutes = elapsedTime.GetMinutes();
					int elapsedSeconds = elapsedTime.GetSeconds().ToLong() % 60;

					if (!distccEnabledForThisProcess)  ///if is a local process 
					{
						int leftTimeUntilKill = (int)CHILD_PROCESS_TIMEOUT - elapsedTime.GetSeconds().ToLong();
						leftTimeUntilKill = leftTimeUntilKill < 0 ? 0 : leftTimeUntilKill;
						if ((cd->GetWarningLevel() == 0) && (elapsedTime.GetSeconds() >= CHILD_PROCESS_TIMEOUT_WARNING1))
						{
							cd->SetWarningLevel(1);
							PRINTF(COLOR_YELLOW, cd->GetLabel() + wxT(" WARNING! This process takes too much time(%dm%ds). I will kill it after %ds !\n"), elapsedMinutes, elapsedSeconds, leftTimeUntilKill);
						}
						else if ((cd->GetWarningLevel() == 1) && (elapsedTime.GetSeconds() >= CHILD_PROCESS_TIMEOUT_WARNING2))
						{
							cd->SetWarningLevel(2);
							PRINTF(COLOR_YELLOW, cd->GetLabel() + wxT(" WARNING! This process takes really too much time(%dm%ds). I will kill it after %ds !\n"), elapsedMinutes, elapsedSeconds, leftTimeUntilKill);
						}
						else if ((cd->GetWarningLevel() == 2) && (elapsedTime.GetSeconds() >= CHILD_PROCESS_TIMEOUT_WARNING3))
						{
							cd->SetWarningLevel(3);
							PRINTF(COLOR_YELLOW, cd->GetLabel() + wxT(" WARNING! This process takes really really too much time(%dm%ds). I will kill it after %ds !\n"), elapsedMinutes, elapsedSeconds, leftTimeUntilKill);
						}
						else if ((cd->GetWarningLevel() == 3) && (elapsedTime.GetSeconds() >= CHILD_PROCESS_TIMEOUT))
						{
							cd->SetWarningLevel(4);

							ExternalCommandThread* t = cd->GetThread();
							long pid = -1;

							if (cd->GetProcess())
							{
								pid = cd->GetProcess()->GetPid();
								if (wxProcess::Exists(pid))
								{
									cd->GetProcess()->Detach();
									cd->GetProcess()->m_markThisToBeKilled = true;
									wxThread::Sleep(1000);

									int killResponse = wxProcess::Kill(pid, wxSIGTERM, wxKILL_CHILDREN);
									if (killResponse == wxKILL_ERROR)
									{
										killResponse = wxProcess::Kill(pid, wxSIGKILL, wxKILL_CHILDREN);
									}

									switch (killResponse)
									{
									case wxKILL_OK:              // no error
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_OK!\n"), pid);
#endif
										break;
									case wxKILL_NO_PROCESS:      // no such process
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_NO_PROCESS!\n"), pid);
#endif
										break;
									case wxKILL_ACCESS_DENIED:   // permission denied
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_ACCESS_DENIED!\n"), pid);
#endif
										break;
									case wxKILL_BAD_SIGNAL:      // no such signal
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_BAD_SIGNAL!\n"), pid);
#endif
										break;
									case wxKILL_ERROR:           // another, unspecified error

										if (sln2gccApp::KillProcessByPID(pid)) ///try to kill using the Win32 function!
										{
											PRINTF(COLOR_RED, cd->GetLabel() + wxT(" Time out -> KILLED! (%dm%ds) \n"), elapsedMinutes, elapsedSeconds);
											sln2gccApp::s_errorsNo++;
										}
										else
										{
											PRINTF(COLOR_RED, cd->GetLabel() + wxT(" Time out -> KILL does not work!\n"));
										}
										break;
									};

								}
							}

							/*
							if(pid != -1)
							{
							wxThread::Sleep(200);
							wxTRY
							{
							if(t && wxProcess::Exists(pid))
							{
							t->Kill();
							}
							}
							wxCATCH_ALL(PRINTF(COLOR_RED, wxT(" Kill thread EXCEPTION!\n")););
							wxThread::Sleep(200);
							}
							*/

							cd->CheckOutput(convertErrorsToWarnings);

							PRINTF(COLOR_RED, wxString(wxT(__FUNCTION__)) + wxT(" ") + cd->GetLabel() + wxT(" remove process from list\n"));

							if (!cd->IsJobEnd())
							{
								PRINTF(COLOR_RED, wxString(wxT("Wait for this process to end .")));
								wxThread::Sleep(5000);
							}

							//while(!cd->IsJobEnd())
							//{
							//    wxThread::Sleep(1000);
							//    PRINTF(COLOR_RED, wxString(wxT(".")));
							//}

							if (cd->IsJobEnd())
							{
								cd->SetIsJobEnd();
								//////////////////////////////////////////////////////////////////////////
								//Memory leak that must be solved!!!
								//delete cd;
								//cd = NULL;
								//////////////////////////////////////////////////////////////////////////
							}
							procArray.erase(procArray.begin() + i);
							i = 0;


						}
					}
					else //if is a distcc process
					{
						int distccProcessTimeout = (sln2gccApp::s_typeOfBuild == STR_RELEASE) ? DISTCC_PROCESS_TIMEOUT : DISTCC_PROCESS_TIMEOUT * 3;
						if ((elapsedTime.GetSeconds() >= distccProcessTimeout)/* || cd->TryToRunLocally()*/)
						{
							PRINTF(COLOR_YELLOW, cd->GetLabel() + wxT(" WARNING! DISTCC is too slow (%dm%ds wasted). Start compiling locally!\n"), elapsedMinutes, elapsedSeconds);
							ExternalCommandThread* t = cd->GetThread();

							long pid = -1;

							if (cd->GetProcess())
							{
								pid = cd->GetProcess()->GetPid();
								if (wxProcess::Exists(pid))
								{
									//cd->GetProcess()->Detach();
									cd->GetProcess()->m_markThisToBeKilled = true;
									wxThread::Sleep(1000);

									int killResponse = wxProcess::Kill(pid, wxSIGTERM, wxKILL_CHILDREN);
									//wxThread::Sleep(10);
									if (killResponse == wxKILL_ERROR)
									{
										killResponse = wxProcess::Kill(pid, wxSIGKILL, wxKILL_CHILDREN);
										//wxThread::Sleep(10);
									}

									switch (killResponse)
									{
									case wxKILL_OK:              // no error
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_OK!\n"), pid);
#endif
										break;
									case wxKILL_NO_PROCESS:      // no such process
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_NO_PROCESS!\n"), pid);
#endif
										break;
									case wxKILL_ACCESS_DENIED:   // permission denied
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_ACCESS_DENIED!\n"), pid);
#endif
										break;
									case wxKILL_BAD_SIGNAL:      // no such signal
#ifdef _DEBUG 
										PRINTF(COLOR_RED, wxT("Killing pid=%lu wxKILL_BAD_SIGNAL!\n"), pid);
#endif
										break;

									case wxKILL_ERROR:           // another, unspecified error
										if (sln2gccApp::KillProcessByPID(pid)) ///try to kill using the Win32 function!
										{
											PRINTF(COLOR_RED, wxT("Pid %lu killed by KillProcessByPID function!\n"), pid);
											sln2gccApp::s_errorsNo++;
										}
										else
										{
											PRINTF(COLOR_RED, cd->GetLabel() + wxT(" Warning KillProcessByPID cannot kill pid %lu !\n"), pid);
										}
										break;
									};

								}
							}

							wxThread::Sleep(2000);

							/*
							if(pid != -1)
							{
							wxThread::Sleep(200);
							wxTRY
							{
							if(t && wxProcess::Exists(pid))
							{
							t->Kill();
							}
							}
							wxCATCH_ALL(PRINTF(COLOR_RED, wxT(" Kill thread EXCEPTION!\n"));)
							wxThread::Sleep(200);
							}
							*/

							//cd->PrintStatus();

							procArray.erase(procArray.begin() + i);
							i = 0;


							/////
							CompileCommandDescriptor* command = ((CompileCommandDescriptor*)cd);
							command->GetProcess()->m_markThisToBeKilled = false;
							command->SetDistcc(wxEmptyString);
							command->SetIsJobEnd(false);
							command->setHasErrors(false);
							command->SetIsInExecution(false);
							command->SetWarningLevel(0);
							///do not delete this pointer - the threads are self deleting pointers.
							ExternalCommandThread* cmdThread = NEW ExternalCommandThread((CommandDescriptor*)command);



							wxThreadError terr = cmdThread->Create();
							//wxFileName::SetCwd(command->m_workingDir);
							cmdThread->Run();
							//wxThread::Sleep(10);
							wxYield();

							if (sln2gccApp::GetEnableVerbose())
							{
								cd->PrintStatus();
							}

							if (terr != wxTHREAD_NO_ERROR)
							{
								PRINTF(COLOR_RED, _T("Thread Execution failed.\n"));

								delete cmdThread;
							}
							else
							{

								s_procLocalArray.push_back(command);
							}
						}
					}
				}
			}
		}
		else///means cd = NULL
		{
			PRINTF(COLOR_RED, _T("ERROR: this is not good! cd == NULL !\n"));

			procArray.erase(procArray.begin() + i);
			i = 0;
		}


		wxYield();
	}

	wxThread::Sleep(5);

	if (processesLeft == 0)
	{
		return (procArray.size() == 0);
	}
	else
	{
		return (procArray.size() < processesLeft);
	}
}

bool VcProject::IsExcludedFromUnityBuild(wxString fileName)
{
	//wxPrintf(wxT("IsExcludedFromUnityBuild ") + fileName);

	wxString fName = wxFileName(fileName).GetFullName();

	int excludedfilesNo = this->m_excludeFileFromAutoGenUB.size();
	for (int ex = 0; ex < excludedfilesNo; ex++)
	{
		if (FileNameMatch(fileName, m_excludeFileFromAutoGenUB[ex]))
		{
			return true;
		}
	}

	return false;
}



bool VcProject::IsIgnored(wxString fileName)
{
	wxString fName = wxFileName(fileName).GetFullName();

	int ignoredFilesNo = this->m_filesIgnored.size();
	for (int ign = 0; ign < ignoredFilesNo; ign++)
	{
		wxFileName ignoredFN(m_filesIgnored[ign]);

		//if there is no extension present try to find the file no matter the extension
		if (ignoredFN.GetExt().Trim() == wxEmptyString)
		{
			if (fName.Find(m_filesIgnored[ign] + wxT(".")) != wxNOT_FOUND)
				return true;
		}
		else
		{
			if (FileNameMatch(fileName, m_filesIgnored[ign]))
				return true;
		}
	}

	return false;
}


bool VcProject::FileNameMatch(wxString fileName, wxString regex)
{
	wxString fName = wxFileName(fileName).GetFullName();

	if ((regex.Find(wxT("*")) != wxNOT_FOUND)
		|| (regex.Find(wxT("?")) != wxNOT_FOUND))
	{
		//for regex rules see: http://docs.wxwidgets.org/trunk/overview_resyntax.html#overview_resyntax_bracket
		regex.Replace(wxT("*"), wxT("[a-zA-Z0-9.[.-.][.[.][.].]_]*"));
		regex.Replace(wxT("?"), wxT("[a-zA-Z0-9.[.-.][.[.][.].]_]"));
		regex += wxT(" ");

		wxRegEx regularExp(regex);

		wxString fnToTest = fName + wxT(" ");

		//wxPrintf(wxT("file ") + fnToTest + wxT("      ") + regex + wxT("\n"));

		if (regularExp.Matches(fnToTest))
		{
			//wxPrintf(wxT("file ") + fnToTest + wxT("   ") + fileName);
			//wxPrintf(wxT(" FOUND! -> is excluded!\n"));
			return true;
		}
	}
	else
	{
		if (fName == regex)
		{
			return true;
		}
	}


	return false;
}