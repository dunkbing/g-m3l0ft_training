#if USE_OPTUS_DRM
package com.msap.store.drm.android.util;

import java.lang.*;
import java.io.*;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.util.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import org.json.*;

/**
 * This class serves a proxy class for the license server.
 * @author Edison Chan
 */
public class ProtocolUtility {
	public final static String ENCODING = "UTF-8";
	public final static String DATA_ENCRYPTION_ALGORITHM = "AES";
	public final static String DATA_ENCRYPTION_MODE = "CBC";
	public final static String DATA_ENCRYPTION_PADDING = "PKCS5Padding";
	public final static String DATA_ENCRYPTION_TRANSFORMATION = "AES/CBC/PKCS5Padding";
	public final static String META_ENCRYPTION_ALGORITHM = "RSA";
	public final static String META_ENCRYPTION_MODE = "ECB";
	public final static String META_ENCRYPTION_PADDING = "PKCS1Padding";
	public final static String META_ENCRYPTION_TRANSFORMATION = "RSA/ECB/PKCS1Padding";
	public final static String DIGEST_ALGORITHM = "SHA-1";

	/**
	 * Generate a nonce for preventing replay attacks.
	 * @return nonce for preventing replays.
	 * @throws GeneralSecurityException
	 */
	public final static String generateClientNonce() 
			throws GeneralSecurityException {
		SecureRandom randmaker = new SecureRandom();
		byte[] data = new byte[32];
		long time1 = System.currentTimeMillis();
		long time2 = System.nanoTime();
		long free = Runtime.getRuntime().freeMemory();
		
		randmaker.nextBytes(data);

		return HexEncoding.encode(data) + 
			":" + Long.toString(time1) +
			":" + Long.toString(time2) +
			":" + Long.toString(free);
	}

	/**
	 * Generate a symmetric key for session key.
	 * @return secret key object containing the generated session key.
	 * @throws GeneralSecurityException
	 */
	public final static byte[] generateSessionKey() 
			throws GeneralSecurityException {
		return KeyGenerator.getInstance(DATA_ENCRYPTION_ALGORITHM).generateKey().getEncoded();
	}
	
	/**
	 * Timestamp a request and return the resultant data in JSON format.
	 * @param request request to be wrapped.
	 * @param clientNonce nonce generated by client for verification of response.
	 * @return the wrapped request.
	 * @throws JSONException when JSON result cannot be constructed.
	 */
	public final static String wrapNonceLayer(String request, String clientNonce) 
			throws JSONException {
		return wrapNonceLayer(request, clientNonce, null);
	}

	/**
	 * Timestamp a request and return the resultant data in JSON format.
	 * @param request request to be wrapped.
	 * @param clientNonce nonce generated by client for verification of response.
	 * @param serverNonce nonce generated by server for verification of request.
	 * @return the wrapped request.
	 * @throws JSONException when JSON result cannot be constructed.
	 */
	public final static String wrapNonceLayer(String request, String clientNonce, String serverNonce) 
			throws JSONException {
		JSONObject object = new JSONObject();
		object.put("type", "nonce-request-layer");
		object.put("version", 1);
		object.put("client-nonce", clientNonce);
		object.put("server-nonce", serverNonce);
		object.put("data", request);

		return object.toString();
	}

	/**
	 * Timestamp a request and return the resultant data in JSON format.
	 * @param response response to be unwrapped.
	 * @param clientNonce client-generated nonce sent in the corresponding request.
	 * @return the unwrapped request.
	 * @throws JSONException when JSON response cannot be parsed.
	 * @throws GeneralSecurityException when client nonce does not match.
	 */
	public final static String unwrapNonceLayer(String response, String clientNonce) 
			throws JSONException, GeneralSecurityException {
		JSONTokener parser = new JSONTokener(response);
		JSONObject object = (JSONObject) parser.nextValue();
		
		if (object.getString("type").equals("nonce-response-layer")) {
			if (clientNonce.equals(object.getString("client-nonce"))) {
				String respdata = object.getString("data");

				if (respdata != null) {
					return respdata;
				} else {
					throw new JSONException("Missing data");
				}
			} else {
				throw new GeneralSecurityException("Invalid timestamp found in the response");
			}
		} else {
			throw new GeneralSecurityException("Unprotected data");
		}
	}

	/**
 	 * Encrypt a plaintext string and return the ciphertext and its associated 
 	 * metadata encoded in JSON format.
	 * @param request request to be encrypted.
	 * @param cid identifier of the certificate.
	 * @param cert certificate used for encryption.
	 * @param key symmetric session key used for encryption.
	 * @return the encrypted request.
	 * @throws JSONException thrown when the JSON string cannot be parsed.
	 * @throws GeneralSecurityException when encryption cannot be done.
	 * @throws UnsupportedEncodingException when UTF-8 is not supported (which almost should not occur).
	 */
	public final static String wrapCryptoLayer(String request, String cid, Certificate cert, byte[] keydata) 
			throws GeneralSecurityException, JSONException, UnsupportedEncodingException {
		Cipher cipher1 = Cipher.getInstance(META_ENCRYPTION_TRANSFORMATION);
		Cipher cipher2 = Cipher.getInstance(DATA_ENCRYPTION_TRANSFORMATION);
		MessageDigest digester = MessageDigest.getInstance(DIGEST_ALGORITHM);
		SecretKey key = new SecretKeySpec(keydata, DATA_ENCRYPTION_ALGORITHM);
		JSONObject ciphertextObject = new JSONObject();

		cipher1.init(Cipher.ENCRYPT_MODE, cert);
		cipher2.init(Cipher.ENCRYPT_MODE, key);

		byte[] requestDataBytes = request.getBytes(ENCODING);
		byte[] requestHashBytes = digester.digest(requestDataBytes);
		byte[] keyBytes = key.getEncoded();
		byte[] ivBytes = cipher2.getIV();

		ciphertextObject.put("type", "protected-request");
		ciphertextObject.put("version", 2);
		ciphertextObject.put("crypto.meta.keyid", cid);
		ciphertextObject.put("crypto.meta.algorithm", META_ENCRYPTION_ALGORITHM);
		ciphertextObject.put("crypto.meta.mode", META_ENCRYPTION_MODE);
		ciphertextObject.put("crypto.meta.padding", META_ENCRYPTION_PADDING);
		ciphertextObject.put("crypto.data.algorithm", DATA_ENCRYPTION_ALGORITHM);
		ciphertextObject.put("crypto.data.mode", DATA_ENCRYPTION_MODE);
		ciphertextObject.put("crypto.data.padding", DATA_ENCRYPTION_PADDING);
		ciphertextObject.put("crypto.digest", DIGEST_ALGORITHM);
		ciphertextObject.put("key", HexEncoding.encode(cipher1.doFinal(keyBytes)));
		ciphertextObject.put("iv", HexEncoding.encode(cipher1.doFinal(ivBytes)));
		ciphertextObject.put("digest", HexEncoding.encode(cipher1.doFinal(requestHashBytes)));
		ciphertextObject.put("data", HexEncoding.encode(cipher2.doFinal(requestDataBytes)));

		return ciphertextObject.toString();
	}

	/**
	 * Decrypt a ciphertext and associated metadata, as returned by encrypt, to 
	 * the original plaintext.
	 * @param response response to be decrypted.
	 * @param key symmetric session key used for encrypting the request.
	 * @return the decrypted request.
	 * @throws JSONException thrown when the JSON string cannot be parsed.
	 * @throws GeneralSecurityException when decryption cannot be done.
	 * @throws UnsupportedEncodingException when UTF-8 is not supported (which almost should not occur).
	 */
	public final static String unwrapCryptoLayer(String response, byte[] keydata) 
			throws JSONException, GeneralSecurityException, UnsupportedEncodingException {
		JSONTokener parser = new JSONTokener(response);
		JSONObject object = (JSONObject) parser.nextValue();
		
		if (object.getString("type").equals("protected-response")) {
			Cipher cipher = Cipher.getInstance(DATA_ENCRYPTION_TRANSFORMATION);
			SecretKey key = new SecretKeySpec(keydata, DATA_ENCRYPTION_ALGORITHM);
			MessageDigest digester = MessageDigest.getInstance(DIGEST_ALGORITHM);
			byte[] ivBytes = HexEncoding.decode(object.getString("iv"));

			cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ivBytes));

			byte[] responseDataBytes = cipher.doFinal(HexEncoding.decode(object.getString("data")));
			byte[] responseHashBytes1 = cipher.doFinal(HexEncoding.decode(object.getString("digest")));
			byte[] responseHashBytes2 = digester.digest(responseDataBytes);

			if (Arrays.equals(responseHashBytes1, responseHashBytes2)) {
				return new String(responseDataBytes, ENCODING);
			} else {
				throw new DigestException("Mismatch between plaintext digest and server digest");
			}
		} else {
			throw new GeneralSecurityException("Input data is not encrypted");
		}
	}
};

#endif	//USE_OPTUS_DRM
